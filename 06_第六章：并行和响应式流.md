# 并行和响应式流

   本章将学习如下内容：

- 创建不同来源的流
- 归约流元素
- 集合流元素
- 应用操作到流的每个元素
- 筛选流元素
- 变换流元素
- 排序流元素
- 流元素中验证条件
- 响应式流编程

## 引言

Java中的**流**通过连续或并行的方式使用**lambda表达式**，在声明式操作管道中进行处理（映射、筛选、转换、简化、集合）的序列元素。Java 8 中引入流概念，并结合lambda表达式成为这个版本中最有意义的新特性之一，改变Java开发中处理大数据集的方式，优化Java语言处理这些元素的方法。

流操作已经引入Stream、DoubleStream、IntStream和LongStream接口，一些如Collectors或者StreamSupport的功能类，一些如Collector的泛函接口，以及不同类中的很多方法，例如Collection接口中的stream()或者parallelStream()方法，Files类中的lines()方法。

通过本章各小节，将学习在开发中如何高效的使用流，不过学之前先了解流最重要的特性：

- 流是数据序列，不是数据结构。流是用来处理数据元素，而不是用来存储的。
- 流的创建可以来自不同的输入源，譬如集合（队列，数组等等）、文件、字符串，或者通过创建提供流元素的类。
- 不能访问流中的元素个体。我们能够定义流的输入源以及对元素进行的操作，通过函数方式定义流操作，并且在中间和终点操作中使用lambda表达式定义要执行的活动。
- 不能修改流输入源，例如，如果筛选一些流元素，则是在流元素上筛选而不是在其输入源中。
- 流定义了两种操作：
  - **中间操作：**这些操作通常伴随结果生成新的流，用来对流元素进行转换、筛选和排序。
  - **终点操作：**这些操作处理流的所有元素来产生结果或者附带效应。执行之后，流将无法再使用。
- 流管道是由零或多个中间操作以及一个最终操作组成。
- 中间操作如下所示：
  - **无状态：**处理流元素时，不受其它元素影响。例如基于特定条件筛选元素。
  - **有状态：**处理流元素时，依赖其它元素。例如，流元素排序。
- **懒加载：**中间操作都是懒加载的，它们在终点操作开始执行之情，不会被加载。如果中间操作检测到它无法影响操作的最终结果时，Java能够避免此操作在流的一个元素或者一组元素上执行。
- 流具有的元素个数不受限，在最终计算中使用诸如limit()或者findFirst()方法能够用来限定元素个数。由于中间操作是懒加载的，所以无边界的流能够在有限的时间内完成执行。
- 流只能使用一次。如前所述，当流的终点操作被执行时，流被认定已消耗且无法再使用。如果需要再次处理相同数据生成不同结果，需要从相同的输入源中创建新的Stream对象。如果尝试使用已消耗的流，将会得到异常。
- 不需要借助外力，能够以连续或者并行方式处理流元素。可以多次指定流的执行模式，但最后一次需要仔细考虑选择的模式。有状态中间操作不会使用所有的并发能力。

Java 9提供一种新的反应流机制，通过异步方式在生产者与消费者之间传递信息。本章包括九小节，学习如何以并行和功能性的方式，创建流及使用所有的中间和终点操作处理大数据集。

## 创建不同来源的流

本节中，学习如何从不同的输入源中创建流。如下所示不同的可选方式：

- Collection接口的parallelStream()方法
- Supplier接口
- 预先定义的元素集
- FIle和文件夹
- 一个数组
- 随机数生成器
- 两个不同的流结合

也可以从其它输入源创建Stream对象（将在“扩展学习”中描述），只是建议前述这些更有用。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 首先，实现本范例中用到的辅助类。创建名为Person的类，包含六个不同类型的属性：String、int、double和Date：

   ```java
   public class Person implements Comparable<Person>{
   	private int id;
   	private String firstName;
   	private String lastName;
   	private Date birthDate;
   	private int salary;
   	private double coeficient;
   ```

2. 创建设置和获取这些属性值的方法，实现compareTo()方法来比较两个Person对象。设定当有相同的firstName和lastName时，两个人是相同的：

   ```java
   	public int compareTo(Person otherPerson) {
   		int compareLastNames = this.getLastName().compareTo(otherPerson.getLastName());
   		if (compareLastNames != 0) {
   			return compareLastNames;
   		} else {
   			return this.getFirstName().compareTo(otherPerson.getFirstName());
   		}
   	}
   ```

3. 然后，创建名为PersonGenerator的类来生成一个随机的Person对象列表。类中实现名为generatePersonList()的静态方法，用来接收想要生成的人数，并且返回对应数量的List<Person>对象。这里包含了方法实例，但可随意改变：

   ```java
   public class PersonGenerator {
   	public static List<Person> generatePersonList (int size) {
   		List<Person> ret = new ArrayList<>();
   		String firstNames[] = {"Mary","Patricia","Linda","Barbara","Elizabeth","James","John","Robert","Michael","William"};
   		String lastNames[] = {"Smith","Jones","Taylor","Williams","Brown","Davies","Evans","Wilson","Thomas","Roberts"};
   		Random randomGenerator=new Random();
   		for (int i=0; i<size; i++) {
   			Person person=new Person();
   			person.setId(i);
   			person.setFirstName(firstNames[randomGenerator.nextInt(10)]);
   			person.setLastName(lastNames[randomGenerator.nextInt(10)]);
   			person.setSalary(randomGenerator.nextInt(100000));
   			person.setCoeficient(randomGenerator.nextDouble()*10);
   			Calendar calendar=Calendar.getInstance();
   			calendar.add(Calendar.YEAR, -randomGenerator.nextInt(30));
   			Date birthDate=calendar.getTime();
   			person.setBirthDate(birthDate);
   			ret.add(person);
   		}
   		return ret;
   	}
   }
   ```

4. 现在，创建名为MySupplier的类，指定其实现String类参数化的Supplier接口：

   ```java
   public class MySupplier implements Supplier<String>{
   ```

5. 定义名为counter的私有AtomicInteger属性，在类的构造函数中初始化：

   ```java
   	private final AtomicInteger counter;
   	public MySupplier() {
   		counter = new AtomicInteger(0);
   	}
   ```

6. 实现定义在Supplier接口中的get()方法，此方法将返回流的下一个元素：

   ```java
   	@Override
   	public String get() {
   		int value = counter.getAndAdd(1);
   		return "String " + value;
   	}
   ```

7. 现在，实现范例的主方法，创建一个包含main()方法的Main类：

   ```java
   public class Main {
   	public static void main(String[] args) {
   ```

8. 首先，从元素列表中创建Stream对象。创建PersonGenerator类生成10000个Person对象的列表，并且使用List对象的parallelStream()方法创建Stream。然后，使用Stream对象的count()方法得到Stream的元素数量：

   ```java
   		System.out.printf("From a Collection:\n");
   		List<Person> persons=PersonGenerator.generatePersonList(10000);
   		Stream<Person> personStream=persons.parallelStream();
   		System.out.printf("Number of persons: %d\n", personStream.count());
   ```

9. 然后，从生成器中创建Stream。创建MySupplier类的对象，然后使用Stream类的静态方法generate()，将创建的对象作为参数传递进去来生成流。最后，使用parallel()方法将创建的流转化成并行流，limit()方法得到流的前十个元素，然后forEach()方法输出这些元素到控制台：

   ```java
   		System.out.printf("From a Supplier : \n");
   		Supplier<String> supplier = new MySupplier();
   		Stream<String> generatorStream = Stream.generate(supplier);
   		generatorStream.parallel().limit(10).forEach(s -> System.out.printf("%s\n", s));
   ```

10. 然后，通过之前定义的元素列表创建流。使用Stream类的of()静态方法创建流，此方法接收参数变量列表。这里我们传递三个String对象，使用流的parallel()方法转换成并行流，并且使用forEach()方法输出值到控制台：

    ```java
    		System.out.printf("From a predefined set of elements:\n");
    		Stream<String> elementsStream=Stream.of("Peter","John","Mary");
    		elementsStream.parallel().forEach(element -> System.out.printf("%s\n", element));
    ```

11. 现在，通过读取文件内容创建流。首先，创建BufferedReader对象来读取指定文件。然后，使用BufferedReader类的lines()方法得到String对象流。流中每个元素讲来自文件的一行。最后，使用parallel()方法得到流的并行形式，并且使用count()方法得到Stream的元素数量。最后需要关闭BufferedReader对象：

    ```java
    		System.out.printf("From a File:\n");
    		try (BufferedReader br = new BufferedReader(new FileReader("nursery.data"));) {
    			Stream<String> fileLines = br.lines();
    			System.out.printf("Number of lines in the file: %d\n\n", fileLines.parallel().count());
    			System.out.printf("********************************************************\n");
    			System.out.printf("\n");
    			br.close();
    		} catch (FileNotFoundException e) {
    			e.printStackTrace();
    		} catch (IOException e) {
    			e.printStackTrace();
    		}
    ```

12. 现在，创建Stream来处理文件夹内容。首先使用Files类的list()方法得到包含文件夹内容的Path对象流。然后，使用Stream对象的parallel()方法转换成并行流并且使用count()方法计算元素个数。最后，需要用到close()方法关闭流：

    ```java
    		System.out.printf("From a Directory:\n");
    		try {
    			Stream<Path> directoryContent = Files.list(Paths.get(System.getProperty("user.dir")));
    			System.out.printf("Number of elements (files and folders):%d\n\n", directoryContent.parallel().count());
    			directoryContent.close();
    			System.out.printf("********************************************************\n");
    			System.out.printf("\n");
    		} catch (IOException e) {
    			e.printStackTrace();
    		}
    ```

13. 下一个将要用到的输入源是数组。首先，创建字符串数组，然后使用Arrays类的stream()方法创建数组元素的流。最后使用parallel()方法将流转换成并行流，以及使用forEach()方法输出流元素到控制台：

    ```java
    		System.out.printf("From an Array:\n");
    		String array[]={"1","2","3","4","5"};
    		Stream<String> streamFromArray=Arrays.stream(array);
    		streamFromArray.parallel().forEach(s->System.out.printf("%s : ", s));
    ```

14. 现在，创建随机双精度数流。首先创建Random对象，然后使用doubles()方法创建DoubleStream对象，将参数10传到此方法中，这样将要创建的流将有十个元素。最后使用parallel()方法将流转换成并行流，使用peek()方法输出每个元素到控制台，使用average()方法计算数字流的平均值，以及使用getAsDouble()方法得到存储在Optional对象中通过average()方法返回的值：

    ```java
    		Random random = new Random();
    		DoubleStream doubleStream = random.doubles(10);
    		double doubleStreamAverage = doubleStream.parallel().peek(d -> System.out.printf("%f :",d)).average().getAsDouble();
    ```

15. 最后，通过两个流结合创建流。首先，使用Stream类的of()方法创建两个String对象流。然后，使用Stream类的concat()方法将这两个流连接成一个新的流。最后，使用Stream类的parallel()方法将流转换成并行流，且使用forEach()方法输出所有元素到控制台：

    ```java
    		System.out.printf("Concatenating streams:\n");
    		Stream<String> stream1 = Stream.of("1", "2", "3", "4");
    		Stream<String> stream2 = Stream.of("5", "6", "7", "8");
    		Stream<String> finalStream = Stream.concat(stream1, stream2);
    		finalStream.parallel().forEach(s -> System.out.printf("%s : ", s));
    	}
    ```

###工作原理

详细查看本范例中使用到的所有创建流的方法：

- 首先，用到List类的parallelStream()方法。事实上，此方法在Collection接口中定义，所以实现此接口的所有类，诸如ArrayList、LinkedList、或者TreeSet类均实现这个方法。可以使用stream()方法创建连续流或者parallelStream()方法创建并行流。
- 然后，用到Supplier接口的一个实现：MySupplier类。这个接口提供get()方法，每次流需要一个元素作处理就调用此方法。因为可以创建无限数量元素的流，所以需要使用方法来限制流元素的个数，例如limit()方法。
- 接下来，用到Stream类的of()方法，这是一个静态方法，接收可变数量的参数，且返回这些参数作为元素的一个Stream。
- 然后，用到BufferedStream类的lines()方法，此方法返回流，其每个元素是读取自BufferedStream的一行。使用此方法读取文件的所有行，也可以使用BufferedReader其它方法实现。
- 然后，用到Files类的list()方法，此方法接收代表操作系统文件夹的Path对象，返回包含文件夹里所有元素的Path对象流。需要注意的是此方法不是递归函数，所以如果文件夹有多个子文件夹的话，将不会继续处理子文件夹内容。在接下来的“扩展学习”部分将看到，Files类还有其它方法来处理流。
- 然后，用到Arrays类的stream()方法，接收数组并且返回数组元素的Stream。如果数组是double、int、或者long型，则返回DoubleStream、IntStream、或者LongStream对象。这些是流的特殊类型，用来处理类似的数字类型。
- 然后，生成包含随机数的流，用到Random类的doubles()方法。传递流长度为参数，但也可以传递流包含的最小值和最大值。
- 最后，用到Stream类的concat()方法，接收两个流并且返回包含这两个流所有元素的一个流。

我们还用到Stream类的一些方法，绝大多数将会在接下来的部分里详细描述，但先在这里提供简单说明：

- count()：返回流中元素个数，这是一个终止操作，且返回一个long型数字。
- limit()：此方法接收数字为参数。如果流元素个数小于此数字，返回包含所有元素的流。否则，返回参数限定的元素个数的流。这是一个终止操作。
- forEach()：此方法会对Stream的每个元素进行特定的动作。本范例中使用这个终止操作输出信息到控制台，通过lambda表达式实现。
- peek()：此方法是一个中间操作，对流中的每个元素执行动作，并且返回相同元素的流。此方法通常作为调试工具，需要注意的是，像所有的中间操作，也是懒加载操作。所以只有在终点操作请求的时候才会对这些元素执行。
- average()：这是定义在IntStream、DoubleStream、和LongStream流中的方法，返回OptionalDouble值。OptionalDouble类表示为可以有值的double数字，它不会为空Stream生成一个值。
- parallel()：此方法将连续Stream转换成并行流。本范例中绝大多数流是连续的，但能够使用Steam类中的这个方法将它们转换成并行流。

### 扩展学习

Java API还包括创建Stream对象的其它方法，在这里我们列举一些，如下所示：

- Files类提供其它创建流的方法：
  - find()：此方法返回满足lambda表达式中指定条件的文件夹中包含的文件，或者子文件夹中的所有文件。
  - walk()：此方法返回包含文件夹及其所有子文件夹包含文件的Path对象流。
- Stream类也提供其它创建流的静态方法：
  - iterate()：此方法创建一个流，其元素通过一元函数作用到初始元素的应用生成的。 流的第一个元素是初始元素，第二个元素是作用到初始元素的应用结果，第三个元素时作用到第二个元素的应用结果，以此类推。
- 最后，String类包含chars()方法，此方法返回构成String的字符值的IntStream。

### 更多关注

现在已经创建流，开始需要处理流元素了，本章所有小节都提供如何处理流元素的方法。

##归约流元素

**MapReduce**是一种编程模型，用于在分布式环境中使用大量在集群中工作的机器来处理非常大的数据集。 这种编程模型有如下两种操作：

- **Map：**此操作将原始元素筛选和转换成更适合归约操作的形式
- **Reduce：**此操作生成来自所有元素的汇总结果，例如数字值的和或平均值。 

这种编程模型已经在函数式编程世界中得到广泛的应用。在Java生态系统中，**Apache软件基金会**的**Hadoop**项目提供此模型的实现。Stream类实现了两个不同的归约操作：

- 纯归约操作，在不同版本的reduce()方法中实现，用来处理元素流获取一个值
- 可变归约操作，在不同版本的collect()方法中实现，用来处理元素流生成可变的数据结构，例如Collection或StringBuilder。

在本节中，将学习如何使用不同版本的reduce()方法从一个值流中生成结果。你可能已经猜到，reduce()方法是Stream中的终点操作。

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 首先，创建本范例中用到的辅助类。查看小节“创建不同来源的流”，复用范例中的Person和PersonGenerator类。 

2. 然后，创建名为DoubleGenerator的类，实现名为generateDoubleList()的方法用来生成双精度数字列表。此方法接收两个参数，其中包含生成列表的程度，以及列表中最大值。 它将生成随机的双精度数字列表：

   ```java
   public class DoubleGenerator {
   	public static List<Double> generateDoubleList(int size, int max) {
   		Random random = new Random();
   		List<Double> numbers = new ArrayList<>();
   		
   		for(int i = 0 ; i < size ; i ++){
   			double value = random.nextDouble() * max;
   			numbers.add(value);
   		}
   		
   		return numbers;
   	}
   ```

3. 实现名为generateStreamFromList()的方法，此方法接收双精度数字列表为参数，并生成包含列表元素的DoubleStream流。因此，使用DoubleStream.Builder类构造流：

   ```java
   	public static DoubleStream generateStreamFromList(List<Double> list) {
   		DoubleStream.Builder builder = DoubleStream.builder();
   		for(Double number : list) {
   			builder.add(number);
   		}
   		return builder.build();
   	}
   }
   ```

4. 创建名为point的类，包括两个双精度属性，x和y，以及对应的get()和set()方法。代码很简单，不在此列出。

5. 创建名为PointGenerator的类，包括名为generatePointList()的方法，此方法接收想要的列表长度，生成并返回随机Point对象列表：

   ```java
   public class PointGenerator {
   	public static List<Point> generatePointList(int size) {
   		List<Point> ret = new ArrayList<>();
   		Random randomGenerator = new Random();
   		for (int i = 0 ; i < size ; i ++) {
   			Point point =new Point();
   			point.setX(randomGenerator.nextDouble());
   			point.setY(randomGenerator.nextDouble());
   			ret.add(point);
   		}
   		return ret;
   	}
   }
   ```

6. 现在创建包含main()方法的Main类。首先，使用DoubleGenerator类生成10000个双精度数字的List：

   ```java
   public class Main {
   
   	public static void main(String[] args) {
   		List<Double> numbers = DoubleGenerator.generateDoubleList(10000, 1000);
   ```

7. Stream类和特定的DoubleStream、IntStream、LongStream类实现一些特殊的归约操作方法。因此，我们使用DoubleGenerator类生成DoubleStream，以及使用count()、sum()、average()、max()和min()方法分别得到元素数量、所有元素的和、所有元素的平均值、流的最大值和最小值。因为只能处理流元素一次，所以每次操作都需要创建新的流。需要注意这些方法只针对DoubleStream、IntStream、和LongStream类。Stream类只有count()方法，其中一些方法返回可选对象。切记这种对象没有任何值，所以在得到值之前应当检查可选对象：

   ```java
   		DoubleStream doubleStream = DoubleGenerator.generateStreamFromList(numbers);
   		
   		long numberOfElements = doubleStream.parallel().count();
   		System.out.printf("The list of numbers has %d elements.\n", numberOfElements);
   		
   		doubleStream = DoubleGenerator.generateStreamFromList(numbers);
   		double sum = doubleStream.parallel().sum();
   		System.out.printf("Its numbers sum %f.\n", sum);
   		
   		doubleStream = DoubleGenerator.generateStreamFromList(numbers);
   		double average = doubleStream.parallel().average().getAsDouble();
   		System.out.printf("Its numbers have an average value of %f.\n", average);
   		
   		doubleStream = DoubleGenerator.generateStreamFromList(numbers);
   		double max = doubleStream.parallel().max().getAsDouble();
   		System.out.printf("The maximum value in the list is %f.\n", max);
   		
   		doubleStream = DoubleGenerator.generateStreamFromList(numbers);
   		double min = doubleStream.parallel().min().getAsDouble();
   		System.out.printf("The minimum value in the list is %f.\n", min);
   ```

8. 然后，使用reduce()方法的第一个版本。此方法接收关联的BinaryOperator作为参数，此参数接收两个相同类型的对象且返回此类型的对象。当此操作已经处理Stream所有元素时，返回相同类型参数化的Optional对象。例如，我们使用此方法计算两个Random对象随机列表的和：

   ```java
   		List<Point> points=PointGenerator.generatePointList(10000);
   		Optional<Point> point=points.parallelStream().reduce((p1,p2) -> {
   			Point p=new Point();
   			p.setX(p1.getX()+p2.getX());
   			p.setY(p1.getY()+p2.getY());
   			return p;
   		});
   		System.out.println(point.get().getX()+":"+point.get().getY());
   ```

9. 然后，使用reduce()方法的第二个版本，与之前的方法类似，但在此情形中，除了组合的BinaryOperator对象，它接收该操作符的标识值（例如0表示和或者1表示产品）并返回正在处理的类型的元素。如果用到的流没有值，则将返回标识值。所以使用这个reduce()方法计算支付的薪水总额。我们使用map()方法将每个Person对象转换成int值（薪水数），所以当Stream对象执行reduce()方法时，具有了int值。在“变换流元素”小节中会获得更多的map()方法信息：

   ```java
   		System.out.printf("Reduce, second version\n");
   		List<Person> persons = PersonGenerator.generatePersonList(10000);
   		long totalSalary=persons.parallelStream().map(p -> p.getSalary()).reduce(0, (s1,s2) -> s1+s2);
   		System.out.printf("Total salary: %d\n",totalSalary);
   ```

10. 最后，使用reduce()方法的第三个版本。当归约操作的结果类型与流元素类型不同时，使用此版本。 我们需要提供返回类型的标识符和实现BiFunction接口的累加器；然后接收返回类型的一个对象和流元素来生成返回类型的值，以及一个组合函数。此函数实现BinaryOperator接口，并且接收返回类型的两个对象用于生成此类型的对象。因此，使用此版本方法来计算任意员工的列表中薪水超过50000的人数：

   ```java
   		Integer value=0;
   		value=persons.parallelStream().reduce(value, (n,p) -> {
   			if (p.getSalary() > 50000) {
   				return n+1;
   			} else {
   				return n;
   			}
   		}, (n1,n2) -> n1+n2);
   		System.out.printf("The number of people with a salary bigger that 50,000 is %d\n",value);
   	}
   }
   ```

###工作原理

本范例中，学习如何使用Java流提供的不同的归约操作。首先，我们使用DoubleStream、IntStream、LongStream类提供的特定归约操作。这些操作用来计算流元素数量、流元素的总和、流元素平均值以及流的最大和最小值。如果使用一般的Stream操作，只包括count()方法来计算流元素。

然后我们用到Stream类提供的三个reduce()方法版本。第一个版本只接收BinaryOperator一个参数，通常会将运算符指定为lambda表达式，但也可以使用实现BinaryOperator接口的类的对象。此操作符将接收流的两个元素，然后生成相同类型的新元素。  例如，我们接收两个Point对象且生成一个新的Point对象。通过BinaryOperator实现的操作必须是组合的，也就是说，如下表达式必须为true：

```mathematica
(a op b) op c = a op (b op c)
```

op是范例中的BinaryOperator。

此版本的reduce()方法返回Optional对象，因为如果流没有元素的话，就没有结果值返回，这样Optional对象将为空。

第二个版本的reduce()方法接收标识值和BinaryOperator。与另一个版本的reduce()方法一样，BinaryOperator必须是组合的，标识值必须是true表达式：

```mathematica
identity op a = a op identity = a
```

这种情况下，reduce()方法返回一个流元素类型相同的元素，如果流没有元素，将返回标识值。

当想要返回与流元素类型不同的值时， 就用到最后一个版本的reduce()方法。此方法有三个参数，一个标识值、一个累加器操作符，和一个组合器操作符。累加器操作符接收返回类型的值和流元素，并生成返回类型的新对象。 

组合器操作符接收两个返回类型的对象来计算出一个新的返回类型对象。标识值是返回类型的标识值，且需要验证如下表达式：

```mathematica
combiner (u, accumulator(identity, t)) == accumulator(u, t)
```

这里u是返回类型的对象，t是流对象。

下图显示本范例在控制台输出的执行信息：

![pics/06_01.jpg](pics/06_01.jpg)

### 扩展学习

我们已经用lambda表达式实现reduce()方法的所有参数。前两个版本的reduce()方法返回BinaryOperator，第三个版本接收BiFunction和BinaryOperator。如果想重用一个复杂的操作符，可以实现一个类，其实现必要的接口，并将该类的对象作为参数作用到这些接口以及Stream类的其它方法上。

### 更多关注

- 本章“创建不同来源的流”小节

## 集合流元素

Java流使用连续或者并行方式来处理序列元素。能够通过不同的数据来源创建流，例如Collection，File或者Array，以及通常用lambda表达式定义的操作序列作用在这些元素上。这些操作被拆分成两种不同的类：

- **中间操作：**这些操作通常伴随结果生成新的流，用来对流元素进行转换、筛选和排序
- **终点操作：**这些操作在处理流元素之后返回结果

流包括来源，零个或多个中间操作，以及一个终点操作。两个最重要的终点操作是：

- 归约操作在处理流元素之后得到唯一结果。此结果通常是被处理数据的总结。“归约流元素”小节解释如何使用Java中的归约操作。
- 集合操作是生成具有处理的流元素结果的数据结构。由于结果是一个可变的数据结构，所以也称为可变还原操作。

本节中，使用Java流中不同版本的collect()方法和附属Collectors类执行集合操作。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 首先，创建本范例中用到的辅助类。查看小节“创建不同来源的流”，复用范例中的Person和PersonGenerator类。 

2. 在Person类中，使用如下代码重写toString()方法，返回人员的姓和名：

   ```java
   	@Override
   	public String toString() {
   		return firstName + " " + lastName;
   	}
   ```

3. 然后，创建名为Counter的类，包括两个属性：名为value的String属性、名为counter的int属性。生成两个属性的get()和set()方法。代码很简单，不在此列出。

4. 现在创建包含Main()方法的Main类，然后使用PersonGenerator类从黄建一个随机的Person对象列表：

   ```java
   public class Main {
   	public static void main(String[] args) {
   		List<Person> persons = PersonGenerator.generatePersonList(100);
   ```

5. 将要实现的第一个集合操作生成一个Map，其中键是人员的姓，值将是具有这个姓的所有人员列表。使用Stream类和Collectors.groupingByConcurrent收集器来实现此操作。然后，使用forEach()方法处理映射的所有键值（姓），且输出这个键值下的人员个数到控制台。作为groupingByConcurrent()方法的参数，传递一个方法引用。如果只调用一个现有的方法，如本范例所示，我们可以在lambda表达式中使用此机制：

   ```java
   		Map<String, List<Person>> personsByName = persons.parallelStream().collect(Collectors.groupingByConcurrent(Person::getFirstName));
   		personsByName.keySet().forEach(key -> {
   			List<Person> listOfPersons = personsByName.get(key);
   			System.out.printf("%s: There are %d persons with that name\n", key, listOfPersons.size());
   		});
   ```

6. 将要实现的第二个集合操作连接所有人员的所有名字。为了实现此操作，用到Person对象的toString()方法，Stream类的collect()方法，以及Collectors类的joining()方法连接特定的char序列拆分的流的所有元素: 

   ```java
   		String message = persons.parallelStream().map(p -> p.toString()).collect(Collectors.joining(","));
   		System.out.printf("%s\n", message);
   ```

7. 在将要实现的下一个集合操作，先将流中的人员拆分成两组。第一组人员的薪水超过50000，其他人员归为第二组。此操作结果是一个Map对象，包括一个Boolean值作为键，人员列表作为值。为了实现此操作，用到Stream类的collect()方法，Collectors类的partitionBy()方法接收Boolean表达式为参数，根据true或者false值，将流元素拆分成两组。然后使用forEach()方法输出生成的列表的元素数量：

   ```java
   		Map<Boolean, List<Person>> personsBySalary =persons.parallelStream().collect(
   			Collectors.partitioningBy(p -> p.getSalary() > 50000)
   		);
   	
   		personsBySalary.keySet().forEach(key -> {
   			List<Person> listOfPersons = personsBySalary.get(key);
   			System.out.printf("%s: %d \n", key, listOfPersons.size());
   		});
   ```

8. 接下来，将要实现的集合操作生成另一个Map。其键是人员的姓，值是对应人员的姓与名连接成字符串。为实现此形式，使用Stream类的collect()方法和Collectors类的toConcurrentMap()方法。将三个lambda表达式作为参数传到toConcurrentMap()方法中，一个获取键，一个获取值，以及一个lambda表达式用来解析最后的映射中键值的情况 。然后，使用forEach()方法处理所有键，以及输出关联值：

   ```java
   		ConcurrentMap<String, String> nameMap = persons.parallelStream().collect(
   			Collectors.toConcurrentMap(p -> p.getFirstName(), p -> p.getLastName(), (s1, s2) -> s1 + ", " + s2));
   		nameMap.forEach((key, value) -> { 
   			System.out.printf("%s: %s \n", key, value); 
   		});
   ```

9. 到此为止，已经实现的collect()方法的所有例子中，使用此方法的版本来接收Collector接口的实现。 还有另一种collect()方法的版本。使用此版本的collect()方法，实现集合操作来生成薪水超过50000的人员列表。向collect()方法传递一个表达式创建List（List::new方法），一个lambda表达式处理列表的流的一个元素，以及一个表达式处理两个列表（List::addAll方法）：

   ```java
   		List<Person> highSalaryPeople = persons.parallelStream().collect(ArrayList::new, (list, person) -> {
   				if (person.getSalary() > 50000) {
   					list.add(person);
   				}
   			},ArrayList::addAll);
   		System.out.printf("High Salary People: %d\n", highSalaryPeople.size());
   ```

10. 最后，生成一个ConcurrentHashMap，包含person对象列表中出现的姓，以及每个姓出现的次数。 我们将使用人员的姓作为键，Counter对象作为值。集合操作的第一个参数将创建新的ConcurrentHashMap对象，第二个参数是BiConsumer接口的一个实现，此接口接收ConcurrentHashMap和Person作为参数。首先，如果人员存在，使用哈希的computeIfPresent()方法增加人员的Counter值。然后，如果人员不存在，使用哈希的computeIfAbsent()方法插入一个新的人员名称。collect()方法的第三个参数是BiConsumer接口的一个实现，此接口接收两个ConcurrentHashMap对象，并且使用merge()方法处理第二个哈希中的所有元素，如果人员不存在或者计数器没增加的话，将这些元素插入到第一个哈希中。

   ```java
   		System.out.printf("Collect, second example\n");
   		
   		ConcurrentHashMap<String, Counter> peopleNames = persons.parallelStream().collect(
   			ConcurrentHashMap::new, (hash, person) -> {
   				hash.computeIfPresent(person.getFirstName(), (name, counter) -> {
   					counter.increment();
   					return counter;
   				});
   				hash.computeIfAbsent(person.getFirstName(), name -> {
   					Counter c=new Counter();
   					c.setValue(name);
   					return c;
   				});
   			},
   			(hash1, hash2) -> {
   				hash2.forEach (10, (key, value) -> {
   					hash1.merge(key, value, (v1,v2) -> {
   						v1.setCounter(v1.getCounter()+v2.getCounter());
   						return v1;
   					});
   				});
   			});
   		peopleNames.forEach((name, counter) -> {
   			System.out.printf("%s: %d\n", name, counter.getCounter());
   		});
   	}
   ```


### 工作原理

在本节介绍中我们提到，collect()方法实现流元素的可变归约。称其为可变归约是因为流的最终结果将是可变的数据结构，例如Map或者List。Java 并发API的Stream类提供collect()方法的两个版本：

第一个版本只接收Collector接口实现作为参数。此接口有七个方法，所以一般不需要再定制方法。取而代之使用工具类Collectors，有许多方法可以为归约操作返回现成的Collectors对象。 本范例中，用到Collectors类的方法如下所示：

- groupingByConcurrent()：此方法返回Collector对象，这个对象通过以并发方式操作流元素来实现一个组，生成Map作为结果数据结构。 此方法接收一个表达式作为参数，获取来自流元素的映射中使用的键值。 在生成的Map里，键将是参数表达式返回的类型，值是流元素的List。 
- joining()：此方法返回Collector，将流元素连接成String。指定三个CharSequence对象，包含一个元素的分隔符、结尾String的前缀和后缀。
- partitioningBy()：此方法返回的Collector与第一个类似。它接收具有流元素的布尔型表达式为参数，并将流元素组织为两组: 一组满足表达式、另一组不符合。最终结果将是布尔型值为键和流元素类型列表为值的映射。
- toConcurrentMap()：此方法返回以并发方式生成ConcurrentMap的Collector，接收三个参数：
  - 生成来自流元素的键的表达式
  - 生成来自流元素的值的表达式
  - 当有两个或多个具有相同键的元素时，由两个结果生成值的表达式。 

Collector有一组定义其行为的特性，可以为特定的收集器确定是否定义。对于我们来说，最重要的是CONCURRENT特性，它指明收集器是否能够以并发方式工作。 在这种情况下，就不能通过创建并行流来利用多核处理器。如果我门使用Collector进行集合操作，还需要考虑Collector的CONCURRENT特性值 。如果以下三个条件均为true的话，则只能具有一个并发归约：

- Stream是并行的（我们已经在流中用到parallel()方法的parallelStream()）
- 收集器具有CONCURRENT特性
- 流是无序的，或者收集器具有UNORDERED特性

本范例中，groupingByConcurrent()和toConcurrentMap()返回具有CONCURRENT特性的收集器，joining()和partitionBy()方法返回不具有这个特性的收集器。

此外，collect()方法还有另一个版本能够在并行流中使用。此版本的collect()方法接收如下三个参数：

- 一个供应函数用来生成集合操作的最终结果类型的数据结构。 在并行流中，有多少线程执行此操作，此方法就被调用多少次。
- 一个累加器函数接收数据结构和流元素，并处理流元素。
- 一个组合函数接收两个数据结构，并生成相同类型的唯一数据结构。 

通过使用lambda表达式来实现这些函数，也能够使用Supplier接口实现供应函数，或者BitConsumer接口实现累加器函数和组合函数（总是用充足的数据类型参数化）。如果输入和输出参数足够的话，也可以使用方法引用（Class::Method）。例如，我们已经用到List::new引用作为供应函数，以及List::addAll方法作为组合函数。也可以使用List::add方法作为累加器函数。还有很多方法用作collect()方法的参数。

下图显示groupingByConcurrent()操作的输出信息：

![pics/06_01.jpg](pics/06_01.jpg)

下图显示toConcurrentMap()操作的输出信息：

![pics/06_03.jpg](pics/06_03.jpg)

### 扩展学习

Collectors类具有很多返回能够在collect()方法中使用的Collect对象的方法。如下所示：

- toList()：此方法返回Collector，将Stream中的所有元素分组成List。
- toCollection()：此方法返回Collector，将Stream中的所有元素分组成Collection。此方法返回创建集合的表达式作为参数，此表达式通过Collector内部使用且在执行结束时返回。
- averagingInt()、averagingLong()和averagingDouble()：这些方法返回Collector，用来计算int、long和double数的平均值。它们接收表达式为参数，将流元素转换成int、long或者double类型。这些方法返回double值。

###更多关注

- 本章“创建不同来源的流”小节

## 应用操作到流的每个元素

本节中，学习如何应用操作到留的所有元素上。我们将使用三个方法：两个终点操作，forEach()和forEachOrdered()方法，以及一个中间操作peek()方法。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 首先，创建本范例中用到的辅助类。查看小节“创建不同来源的流”，复用范例中的Person类创建人员的基本属性。 

2. 因为范例方法依赖流元素的顺序，所以Person类的一些方法需要重写。首先，重写compareTo()方法比较两个人员，使用Comparator对象创建静态Comparator对象，比较两个Person对象的姓与名。然后，在compareTo()方法中使用比较器：

   ```java
   	private static Comparator<Person> comparator=Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName);
   	@Override
   	public int compareTo(Person otherPerson) {
   		return comparator.compare(this, otherPerson);
   	}
   ```

3. 然后，重写equals()方法来确定两个Person对象是否相同。与compareTo()方法中的做法一样，我们使用已经创建好的Comparator静态对象：

   ```java
   	@Override
   	public boolean equals(Object object) {
   		return this.compareTo((Person)object)==0;
   	}
   ```

4. 最后，重写hashCode()方法为Person对象计算哈希值。在Java中，相同的对象必须生成一样的哈希码，所以需要重写此方法，使用姓和名属性以及Objects类的hash()方法生成Person对象的哈希码：

   ```java
   	public int hashCode() {
   		String sequence=this.getLastName()+this.getFirstName();
   		return sequence.hashCode();
   	}
   ```

5. 本范例中，还要用到“创建不同来源的流”小节中的PersonGenerator和DoubleGenerator类。

6. 现在创建包含main()方法的Main类。首先，创建包含10个随机Person对象的列表：

   ```java
   public class Main {
   	public static void main(String[] args) {
   		List<Person> persons = PersonGenerator.generatePersonList(10);
   ```

7. 然后，使用forEach()方法输出生成的列表中所有人员的名字。forEach()方法将作用到每个元素的表达式作为参数接收到，在这里，我们使用lambda表达式输出信息到控制台：

   ```java
   		persons.parallelStream().forEach(p -> {
   			System.out.printf("%s, %s\n", p.getLastName(), p.getFirstName());
   		});
   ```

8. 接下来，学习如何以有序方式对每个元素进行操作。 首先，使用DoubleGenerator类创建随机Double数字列表。然后，创建并行流，使用sorted()方法排序流元素，使用forEachOrdered()方法按照顺序将数字输出到控制台：

   ```java
   		List<Double> doubles = DoubleGenerator.generateDoubleList(10, 100);
   		System.out.printf("Parallel forEachOrdered() with numbers\n");
   		doubles.parallelStream().sorted().forEachOrdered(n -> {
   			System.out.printf("%f\n", n);
   		});
   ```

9. 现在，让我们查看如果排序了流元素，但没有使用forEachOrdered()方法会出现什么情况。重复之前的代码，使用forEach()方法来替代：

   ```java
   		System.out.printf("Parallel forEach() afer sorted() with numbers\n");
   		doubles.parallelStream().sorted().forEach(n -> {
   			System.out.printf("%f\n", n);
   		});
   ```

10. 然后，使用Person对象流测试forEachOrdered()方法如何工作：

    ```java
    		persons.parallelStream().sorted().forEachOrdered(p -> {
    			System.out.printf("%s, %s\n", p.getLastName(), p.getFirstName());
    		});
    ```

11. 最后，测试peek()方法，此方法与forEach()方法类似，但它是一个中间操作，通常用来日志操作：

    ```java
    		doubles
    			.parallelStream()
    			.peek(d -> System.out.printf("Step 1: Number: %f\n",d))
    			.peek(d -> System.out.printf("Step 2: Number: %f\n",d))
    			.forEach(d -> System.out.printf("Final Step: Number: %f\n",d));
    	}
    ```

### 工作原理

在本节中，学习了三个方法来处理流的所有元素，并且在这些元素上进行操作，这些方法如下：

- forEach()：这是一个终点操作，对Stream的所有元素应用操作，并返回void值。它将作用在元素上的操作作为参数接收，此操作被定义为lambda表达式或者Comsumer接口实现。无法保证对于将操作应用于并行流的元素顺序。
-  forEachOrdered()：这是一个终点操作，按照流顺序对Stream的所有元素应用操作，如果流是一个顺序流则返回void值。此方法能够在sorted()方法之后使用，首先使用sorted()方法排序流元素，然后使用forEachOrdered()方法按照流顺序进行操作。在并行流中也能够保证此特性，但其性能将比使用无序流的forEach()方法更差。
- peek()：这是一个中间操作，返回包含调用此方法的流的相同元素，并且将操作作为参数应用到流中消耗的所有元素。作用到元素上操作被指定成lambda操作或者Consumer接口实现。需要注意的是，由于中间操作是懒加载，所以此操作只有在终点操作执行时才能应用到通过流消耗的元素。

### 扩展学习

考虑到如果使用排序方法，需要提供作用到待排序元素的Comparator，或者必须实现Comparable接口的流元素。本范例中，Person类实现此接口和compareTo()方法，通过元素的姓和名对流元素进行排序。

### 更多关注

- 本章“创建不同来源的流”、“归约流元素”和“排序流元素”小节

## 筛选流元素

应用在流上最重要的一个应用是筛选操作，用来选择需要处理的元素。本节将学习使用Stream类提供的不同方法选择流元素。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 首先，创建本范例中用到的辅助类。实现Person类存储人员基本属性，PersonGenerator类生成随机Person对象列表。请查看小节“应用操作到流的每个元素”中这两个类的源码。

2. 然后，实现包含main()方法的Main类。首先使用PersonGenerator类创建随机Person对象列表，使用forEach()方法输出生成的元素：

   ```java
   public class Main {
   	public static void main(String[] args) {
   		List<Person> persons=PersonGenerator.generatePersonList(10);
   		persons.parallelStream().forEach(p-> {
   			System.out.printf("%s, %s\n", p.getLastName(),
   			p.getFirstName());
   		});
   ```

3. 接下来，使用distinct()方法消除重复对象。使用forEach()方法输出传递到筛选器的元素：

   ```java
   		persons.parallelStream().distinct().forEach(p-> {
   			System.out.printf("%s, %s\n", p.getLastName(),
   			p.getFirstName());
   		});
   ```

4. 然后，使用数字数组测试distinct()方法，创建数字数组，包括一些重复数字。使用Arrays类的asList()方法将数组转换成列表，使用parallelStream()方法创建并行流，以及mapToInt()方法将流转换成IntStream流，接着使用distinct()方法删除重复元素，最后使用forEach()方法输出最终元素到控制台：

   ```java
   		Integer[] numbers={1,3,2,1,2,2,1,3,3,1,1,3,2,1};
   		Arrays.asList(numbers).parallelStream().mapToInt(n -> n).distinct().forEach( n -> {
   			System.out.printf("Number: %d\n", n);
   		});
   ```

5. 现在，在随机人员列表中得到薪水低于3000的员工，用到筛选器方法以及将此条件表示为lambda表达式天条件。与其它范例一样，使用forEach()方法输出结果元素：

   ```java
   		persons.parallelStream().filter(p -> p.getSalary() < 30000).forEach( p -> {
   			System.out.printf("%s, %s\n", p.getLastName(),
   			p.getFirstName());
   		});
   ```

6. 然后，使用IntStream测试filter()方法得到小于2的数字：

   ```java
   		Arrays.asList(numbers).parallelStream().mapToInt(n -> n).filter( n -> n<2).forEach( n-> {
   			System.out.printf("%d\n", n);
   		});
   ```

7. 接下来，使用limit()方法限制流中的元素数量。例如，从随机人员列表中创建并行流，使用mapToDouble()方法将这些元素转换成DoubleStream，然后使用limit()方法得到前五个元素：

   ```java
   		persons.parallelStream().mapToDouble(p -> p.getSalary()).sorted().limit(5).forEach(s-> {
   			System.out.printf("Limit: %f\n",s);
   		});
   ```

8. 最后，使用skip()方法略去流中的部分元素。从随机人员列表中创建并行流，使用mapToDouble()方法将这些元素转换成DoubleStream，然后使用skip()方法略去前五个元素：

   ```java
           persons.parallelStream().mapToDouble(p -> p.getSalary()).sorted().skip(5).forEach(s-> {
               System.out.printf("Skip: %f\n",s);
           });
           }
   ```

### 工作原理

本节中用到四个方法筛选流元素，如下所示：

- distinct()：此方法通过Stream类元素的equals()方法，返回包含当前流中重复元素的流。本范例中，已经使用Person对象和int数字测试此方法，在Person类中实现了equals()和hashCode()方法。如果不做此操作，equal()方法在两个比较对象具有相同引用时只返回true。考虑到此操作是有状态操作，对并行流操作无法有更好的性能（Java文档中提到，“...在并行计算下，包含有状态中间操作的管道可能需要多次传递数据，或者需要缓冲大量数据… ”）。
- filter()：此方法将Predicate作为参数接收，这个条件可以表示为返回布尔值的lambda表达式。 filter()方法返回带有使Predicate为true的元素的流。
- limit()：此方法将int值作为参数接收，且返回不超过所有元素数量的流。对于有序的并行流，这种方法的性能也会很差，尤其当想要获得的元素数量非常大，因为此方法将返回流的第一个元素，这意味着额外的计算 。这种情况不会发生在无序流中，因为对于无序流来说，返回什么元素并不重要。 
- skip()：此方法在丢弃最初的元素之后返回一个包含原始流元素的流。将丢弃的元素的数量作为此方法的参数，其性能问题与limit()方法相同。 

### 扩展学习

流类中海油其它两个方法可用来筛选流的元素：

- dropWhile()：此方法将Predicate表达式作为参数接收，它对有序流和无序流的处理行为不相同。对于有序流，此方法删除流中匹配条件的第一批元素。当元素符合条件时此方法开始删除元素，当发现元素不符合条件时，停止删除元素并返回剩下元素的流。对于无序流，此方法的处理方式不确定，它删除与条件匹配的元素子集，但不指定要删除哪些元素。 和其它方法一样，在处理并行排序流时性能很差。
- takeWhile()：此方法与dropWhile()方法特性相同，但是用来加载元素。

### 更多关注

- 本章“创建不同来源的流”、“归约流元素”和“集合流元素”小节

## 变换流元素

作用在流上最重要的一些中间操作是对流元素进行转换。这些操作接收一个类的元素并且返回不同类的元素，甚至能够改变流的类型，从Stream生成IntStream、LongStream或者DoubleStream。

本节中，学习如何使用Stream类的转换中间操作将元素变成其它类的元素。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 首先，创建本范例中用到的辅助类。实现Person类存储人员基本属性，PersonGenerator类生成随机Person对象列表。请查看小节“应用操作到流的每个元素”中这两个类的源码。

2. 创建名为BasicPerson的类，包括名为name的String属性和age的long属性。创建这两个属性的get()和set()方法，代码很简单，不在此列出。

3. 创建附属类FIleGenerator，包括名为generateFile()方法，用来接收模拟文件的行数，并将文件对应内容作为String列表返回：

   ```java
   public class FileGenerator {
   	public static List<String> generateFile(int size) {
   		List<String> file = new ArrayList<>();
   		for (int i=0; i<size; i++) {
   			file.add("Lorem ipsum dolor sit amet, consectetur adipiscing elit. "
   					+ " Morbi lobortis cursus venenatis. "
   					+ " Mauris tempus elit ut malesuada luctus."
   					+ " Interdum et malesuada fames ac ante ipsum primis in faucibus. "
   					+ " Phasellus laoreet sapien eu pulvinar rhoncus. "
   					+ " Integer vel ultricies leo. Donec vel sagittis nibh."
   					+ " Maecenas eu quam non est hendrerit pu");
   		}
   		return file;
   	}
   }
   ```

4. 然后，创建包括main()方法的Main类。首先，使用PersonGenerator类创建随机的Person对象列表：

   ```java
   public class Main {
   	public static void main(String[] args) {
   		List<Person> persons = PersonGenerator.generatePersonList(100);
   ```

5. 然后，使用mapToDouble()方法将Person对象流转换成双精度数字的DoubleStream。使用parallelStream ()方法创建并行流，然后使用mapToDouble()方法，将lambda表达式作为参数传递，此表达式接收Person对象并返回其双精度的工资数。 接着使用distinct()方法得到重复值，以及forEach()方法将它们输出到控制台。使用count()方法还得到输出不同元素的数量：

   ```java
   		DoubleStream ds = persons.parallelStream().mapToDouble(p -> p.getSalary());
   		ds.distinct().forEach(d -> {
   			System.out.printf("Salary: %f\n", d);
   		});
   		ds = persons.parallelStream().mapToDouble(p -> p.getSalary());
   		long size = ds.distinct().count();
   		System.out.printf("Size: %d\n", size);
   ```

6. 现在，将流的Person对象转换成BasicPerson对象。使用parallelStream()创建流，以及map()方法转换对象。此方法将接收Person对象的lambda表达式作为参数接收，创建新的BasicPerson对象并赋值。接下来，使用forEach()方法输出BasicPerson对象的属性值到控制台：

   ```java
   		List<BasicPerson> basicPersons = persons.parallelStream().map(p -> {
   			BasicPerson bp = new BasicPerson();
   			bp.setName(p.getFirstName() + " " + p.getLastName());
   			bp.setAge(getAge(p.getBirthDate()));
   			return bp;
   		}).collect(Collectors.toList());
   		
   		basicPersons.forEach(bp -> {
   			System.out.printf("%s: %d\n", bp.getName(), bp.getAge());
   		});
   ```

7. 接下来，我们学习如何管理中间操作返回Steam的情况。 本范例中，将使用流的Stream，但使用flatMap()方法将所有Stream对象连接到唯一的Stream中。 使用FileGenerator类生成包含100个元素的List<String>，然后使用parallelStream()方法创建并行流，使用split()方法拆分每行来得到词语，并且使用Stream类的of()方法，将Array结果装换成Stream。如果使用map()方法，将生成流的Stream，但使用flatMap()方法得到包含整个列表的所有单词的字符串对象的唯一Stream。 然后，使用filter()方法获得长度大于零的词语，使用sorted()方法排序流，使用groupingByConcurrent()方法将流集合成Map，其中键是词语，值为每个词在流中出现的次数：

   ```java
   		List<String> file = FileGenerator.generateFile(100);
   		Map<String, Long> wordCount = file.parallelStream()
   			.flatMap(line -> Stream.of(line.split("[ ,.]")))
   			.filter(w -> w.length() > 0).sorted()
   			.collect(Collectors.groupingByConcurrent(e -> e, Collectors
   			.counting()));
   		wordCount.forEach((k, v) -> {
   			System.out.printf("%s: %d\n", k, v);
   		});
   	}
   ```

8. 最后，需要实现之前用到过的getAge()方法，此方法接收Person对象的生日，返回其年龄：

   ```java
   	private static long getAge(Date birthDate) {
   		LocalDate start = birthDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
   		LocalDate now = LocalDate.now();
   		long ret = ChronoUnit.YEARS.between(start, now);
   		return ret;
   	}
   ```

### 工作原理

本节学习如何使用中间操作和表达式转换流元素，在流和目标类型之间实现转换。本范例中用到三个不同的方法：

- mapToDouble()：使用此方法把Stream对象转换成双精度数字元素的DoubleStream。此方法将lambda参数或者ToDoubleFunction接口实现作为参数接收，这个表达式接收Stream元素，且需要返回双精度数。
- map()：当需要将Stream元素转成不同类时，使用此方法。例如本范例中，将Person类转换成BasicPerson类。此方法将lambda参数或者Function接口实现作为参数接收，这个表达式必须创建新的对象并且初始化其属性。
- flatMap()：当需要将Stream对象的流转换成唯一Stream时，对于这种复杂的情况使用此方法更有效。此方法将lambda表达式作为参数，或者Function接口实现作为map()函数接收，但这种情况下，此表达式需要返回Stream对象。flatMap()方法将自动把所有流连接成一个唯一的Stream。

### 扩展学习

Stream类还提供转换Stream元素的其它方法：

- mapToInt()，mapToLong()：这些方法mapToDouble()方法相同，只是它们分别生成IntStream和LongStream对象。
- flatMapToDouble()，flatMapToInt()，flatMapToLong()：这些方法与flatMap()方法相同，不过分别作用到DoubleStream、IntStream和LongStream。

###更多关注

- 本章“创建不同来源的流”、“归约流元素”和“集合流元素”小节

## 排序流元素

排序流元素是Stream的典型操作。例如，需要按照名称、邮编，或者其它任何数字值对Stream元素进行排序。

对于流，我们还需要考虑所谓的出现顺序。 一些流可能有一个定义好的出现顺序（这取决于Stream的来源）。有些操作使用出现顺序中的流元素，例如limit()、skip()和其他操作，使得这些方法的并行计算性能很差。这种情况下，通过删除排序约束，可以加速方法执行时间。

本节将学习如何排序Stream元素，以及在不需要Stream出现顺序的情况下，如何删除排序约束。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 首先，创建本范例中用到的辅助类。实现Person类存储人员基本属性，PersonGenerator类生成随机Person对象列表。请查看小节“应用操作到流的每个元素”中这两个类的源码。

2. 现在，创建包括main()方法的Main类。首先，创建int数字数组，使用这个数组中的parallelStream()方法创建并行流，使用sort()方法对数组中的元素进行排序，并使用forEachOrdered()方法按照顺序输出元素。因为此操作需要按照指定的顺序来输出元素，所以无法使用多核处理器的所有性能：

   ```java
   public class Main {
   	public static void main(String[] args) {
   		int[] numbers={9,8,7,6,5,4,3,2,1,2,3,4,5,6,7,8,9};
   		Arrays.stream(numbers).parallel().sorted().forEachOrdered(n -> {
   			System.out.printf("%d\n", n);
   		});
   ```

3. 现在，使用Person对象的Stream尝试相同的操作，使用PersonGenerator类创建10个随机Person对象列表，并且使用相同的sorted()和forEachOrdered()方法，查看人员如何按照顺序输出：

   ```java
   		List<Person> persons=PersonGenerator.generatePersonList(10);
   		persons.parallelStream().sorted().forEachOrdered(p -> {
   			System.out.printf("%s, %s\n",p.getLastName(),p.getFirstName());
   		});
   ```

4. 最后查看如何使用unordered()方法打乱数据结构的出现顺序。首先，从随机Person对象的列表中创建TreeSet，使用TreeSet是因为它在内部排序元素。然后使用循环重复10次操作来看排序和非排序操作之间有什么区别：

   ```java
   		TreeSet<Person> personSet=new TreeSet<>(persons);
   		for (int i=0; i<10; i++) {
   ```

5. 然后，使用stream()方法创建流，parallel()方法将其转换成并行流，使用limit()方法得到第一个元素且返回Person对象，集合成列表并得到第一个元素：

   ```java
   		Person person= personSet.stream().parallel().limit(1).collect(Collectors.toList()).get(0);
   			System.out.printf("%s %s\n", person.getFirstName(),person.getLastName());
   ```

6. 现在，执行相同的操作，但在stream()和parallel()方法之间使用unordered()删除排序约束：

   ```java
   			person=personSet.stream().unordered().parallel().limit(1).collect(Collectors.toList()).get(0);
   			System.out.printf("%s %s\n", person.getFirstName(), person.getLastName());
   		}
   	}
   }
   ```

### 工作原理

因为流的来源以及应用到流上的中间操作，使得Stream对象会存在出现顺序。在元素必须通过特定方法处理时，出现顺序会利用此限制进行排序。例如，如果在流中按照出现顺序使用limit()或者skip()方法，考虑到出现顺序将获得和忽略第一个元素。还有其他操作，例如forEach()方法，就不需要考虑出现顺序。如果按照出现顺序对流应用相同操作，结果也是相同的。如果流没有出现顺序，结果可能是变化的。

当使用顺序流时，出现顺序对应用性能没有任何影响，但是并行流会对性能产生很大影响。根据操作不同，需要多次处理流元素，或者在缓冲区中存储大量数据。这种情况下，如本节中所用到的，使用unordered()方法删除出现顺序，会显著提升应用性能。

另一方面，sorted()方法对流元素进行排序，如果使用此方法，流元素必须实现Comparable接口。否则可以将用来排序元素的comparator作为参数传递，如果您使用此方法，您将创建一个有序流，因此，之前讲解的所有具有出现顺序的流都适用于合成流。 

最后，forEach()方法不考虑流的出现顺序，如果要考虑出现顺序，例如排序后按顺序写入流元素 ，可以使用forEachOrdered()方法。 

下图显示本范例在控制台输出的执行信息：

![pics/06_04.jpg](pics/06_04.jpg)

可以看到当在生成自TreeSet的并行流中调用limit(1)时，因为流API遵循结构的出现顺序，所以通常会得到相同的结果。但是当调用unordered()方法时，则不考虑出现顺序，且得到的结果是可变的，如本范例所示。

### 扩展学习

当使用unordered()方法时，任何在数据结构中内部改变的元素顺序的代码都未执行，只是删除可能将某些方法考虑在内的一个条件。使用unordered()方法的流结果与为使用此方法的流结果可能是相同的，其用法可能会对并行流产生不同的处理结果。 例如，如果在本范例中使用Person对象列表代替TreeSet的personSet，两种情况下的均能得到相同的结果。

如前所述，unordered()方法的主要目的是删除制约并行流性能的排序约束。

### 更多关注

- 本章“创建不同来源的流”、“归约流元素”和“集合流元素”小节

## 流元素中验证条件

Stream类提供了一个有趣的功能，检查流的元素是否验证条件，此功能由返回布尔值的终点操作提供。 

本节中，学习Stream类中哪些方法在流元素中验证条件，以及如何使用它们。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 首先，创建本范例中用到的辅助类。实现Person类存储人员基本属性，PersonGenerator类生成随机Person对象列表。请查看小节“应用操作到流的每个元素”中这两个类的源码。

2. 然后，创建包括main()方法的Main类。首先，使用PersonGenerator类创建随机Person对象列表：

   ```JAVA
   public class Main {
   	public static void main(String[] args) {
   		List<Person> persons=PersonGenerator.generatePersonList(10);
   ```

3. 接下来，计算薪资字段的最大值和最小值，以验证所有的计算都是正确的 。我们用两个流来计算，第一个包含map()和max()方法，第二个包含mapToInt()和min()方法：

   ```java
   		int maxSalary = persons.parallelStream().map(p -> p.getSalary()).max(Integer::compare).get();
   		int minSalary = persons.parallelStream().mapToInt(p -> p.getSalary()).min().getAsInt();
   		System.out.printf("Salaries are between %d and %d\n", minSalary, maxSalary);
   ```

4. 现在，测试一些条件。首先，使用allMatch()方法和相应的lambda表达式来验证所有生成的Person对象的工资是否大于0: 

   ```java
   		boolean condition;
   		condition=persons.parallelStream().allMatch(p -> p.getSalary() > 0);
   		System.out.printf("Salary > 0: %b\n", condition);
   ```

5. 重复此条件测试是否所有的薪水范围在10000到30000之间：

   ```java
   		condition=persons.parallelStream().allMatch(p -> p.getSalary() > 10000);
   		System.out.printf("Salary > 10000: %b\n",condition);
   		condition=persons.parallelStream().allMatch(p -> p.getSalary() > 30000);
   		System.out.printf("Salary > 30000: %b\n",condition);
   ```

6. 然后，使用anyMatch()方法测试是否有人的薪水范围在50000到100000之间：

   ```java
   		condition=persons.parallelStream().anyMatch(p -> p.getSalary() > 50000);
   		System.out.printf("Any with salary > 50000: %b\n",condition);
   		condition=persons.parallelStream().anyMatch(p -> p.getSalary() > 100000);
   		System.out.printf("Any with salary > 100000: %b\n",condition);
   ```

7. 为了完成这部分测试，使用noneMatch()方法验证没有人的薪大于100000：

   ```java
   		condition=persons.parallelStream().noneMatch(p -> p.getSalary() > 100000);
   		System.out.printf("None with salary > 100000: %b\n",condition);
   ```

8. 接下来，使用findAny()方法得到Person对象流的一个随机元素：

   ```java
   		Person person = persons.parallelStream().findAny().get();
   		System.out.printf("Any: %s %s: %d\n", person.getFirstName(), person.getLastName(), person.getSalary());
   ```

9. 然后，使用findFirst()方法得到Person对象流的第一个元素：

   ```java
   		person = persons.parallelStream().findFirst().get();
   		System.out.printf("First: %s %s: %d\n", person.getFirstName(), person.getLastName(), person.getSalary());
   ```

10. 最后，使用sorted()方法按照薪水值对流进行排序，传递表示为lambda表达式的Comparator，且在本范例中，使用findFirst()方法得到薪水最低的Person对象：

    ```java
    		person = persons.parallelStream().sorted((p1,p2) -> {
    			return p1.getSalary() - p2.getSalary();
    		}).findFirst().get();
    		System.out.printf("First Sorted: %s %s: %d\n", person.getFirstName(), person.getLastName(), person.getSalary());
    	}
    }
    ```

### 工作原理

本节中，我们用到三个不同的方法来验证流元素的条件：

- allMatch()：此方法为终点操作，将表示为lambda表达式的Predicate接口实现，或者实现此接口的对象作为参数接收，并且返回布尔值。如果引入的Predicate对所有流元素为true，则返回true，否则返回false。 
- anyMatch()：此方法为终点操作，将表示为lambda表达式的Predicate接口实现，或者实现此接口的对象作为参数接收，并且返回布尔值。如果引入的Predicate对至少一个流元素为true，则返回true，否则返回false。 
- noneMatch()：此方法为终点操作，将表示为lambda表达式的Predicate接口实现，或者实现此接口的对象作为参数接收，并且返回布尔值。如果引入的Predicate对所有流元素为false，则返回true，否则返回false。 

我们还用到两个方法获得流元素：

- findAny()：此方法是终点操作，它不接收参数且返回由流元素类参数化的Optional对象。 无法确定通过此方法返回的元素，如果流没有元素，则返回的Optional对象为空。
- findFirst()：此方法是终点操作，它不接收参数且返回由流元素类参数化的Optional对象。如果流具有特定的出现顺序则返回第一个流元素，反之则返回任何元素。如果流没有元素，则返回的Optional对象为空。

### 扩展学习

本节用到了Java API提供的接口和类，Predicate接口是一个功能接口，通常表示为lambda表达式，此表达式接收流元素，且返回布尔值。如果想要创建类来实现此接口，只需要实现test()方法，接收参数化类型的对象，并且返回布尔值。这个接口定义了很方法，但都具有一个默认实现。

当流的终点操作不确定是否返回值时，使用Optional类。通过这种方式，Java保证操将始终返回值，Optional对象可能包含使用get()方法获得的值，也可能是一个空对象，通过使用isPresent()方法来检查此条件。 如果使用get()方法得到空的Optional对象，将会抛出NoSuchElementException。

### 更多关注

- 本章“创建不同来源的流”、“归约流元素”和“集合流元素”小节

##响应式流编程

**响应式流**（http://www.reactive-streams.org/）提供了具有非阻塞压力的异步流处理机制。

 响应式流基于以下三个要素：

- 信息发布者
- 多个信息订阅者
- 发布者与消费者之间的订阅

响应式流规范确定这些类应当如何交互，依据如下规则：

- 发布者添加希望被通知的订阅者 
- 当订阅者添加到发布者处时接收到通知
- 订阅者以异步方式从发布者处请求一个或多个元素，也就是说，订阅者请求元素且继续执行
- 当发布者有元素需要发布时，将发送此元素到所有请求元素的订阅者

如前所述，所有通信都是异步的，所以我们能够利用多核处理器的所有功能。

Java 9中包含三个接口，Flow.Publisher、Flow.Subscriber和Flow.Subscription，以及一个工具类SubmissionPublisher，用来实现响应式流应用。在本节中，将学习如何使用这些元素实现基本的响应式流应用。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

在本节中，将实现之前描述的如何通过输入源创建流的范例。通过如下步骤实现范例：

1. 创建名为Item的类，用来表示从发布者发送到订阅者的信息项。包含两个名为title和content的String属性，以及对应值的get()和set()方法。代码很简单，不在此列出。

2. 然后，创建名为Consumer1的类，指定其实现Item类参数化的Subscriber接口。需要实现四个方法，首先实现onComplete()方法，用来输出一条信息到控制台：

   ```java
   public class Consumer1 implements Flow.Subscriber<Item>{
   	@Override
   	public void onComplete() {
   		System.out.printf("%s: Consumer 1: Completed\n", Thread.currentThread().getName());
   	}
   ```

3. 接下来，实现onError()方法，用来输出错误信息到控制台：

   ```java
   	@Override
   	public void onError(Throwable exception) {
   		System.out.printf("%s: Consumer 1: Error\n", Thread.currentThread().getName());
   		exception.printStackTrace(System.err);
   	}
   ```

4. 然后，实现onNext()方法，输处接收的条目信息到控制台：

   ```java
   	@Override
   	public void onNext(Item item) {
   		System.out.printf("%s: Consumer 1: Item received\n",Thread.currentThread().getName());
   		System.out.printf("%s: Consumer 1: %s\n", Thread.currentThread().getName(), item.getTitle());
   		System.out.printf("%s: Consumer 1: %s\n", Thread.currentThread().getName(), item.getContent());
   	}
   ```

5. 最后，实现onSubscribe()方法，输出信息到控制台，不使用Subscription对象的request()方法请求任何项: 

   ```java
   	@Override
   	public void onSubscribe(Flow.Subscription subscription) {
   		System.out.printf("%s: Consumer 1: Subscription received\n", Thread.currentThread().getName());
   		System.out.printf("%s: Consumer 1: No Items requested\n", Thread.currentThread().getName());
   	}
   }
   ```

6. 现在创建Consumer2类，也指定其实现Item类参数化的Subscriber接口。这里包括一个使用Subscription属性来存储订阅对象，其中onComplete()和onError()方法与Consumer1类中的方法相同：

   ```java
   public class Consumer2 implements Flow.Subscriber<Item>{
   
   	private Subscription subscription;
   	
   	@Override
   	public void onComplete() {
   		System.out.printf("%s: Consumer 2: Completed\n",
   		Thread.currentThread().getName());
   	}
   	
   	@Override
   	public void onError(Throwable exception) {
   		System.out.printf("%s: Consumer 2: Error\n", Thread.currentThread().getName());
   		exception.printStackTrace(System.err);
   	}
   ```

7. onNext()方法附加一行代码，请求另一个元素：

   ```java
   	@Override
   	public void onNext(Item item) {
   		System.out.printf("%s: Consumer 2: Item received\n", Thread.currentThread().getName());
   		System.out.printf("%s: Consumer 2: %s\n", Thread.currentThread().getName(), item.getTitle());
   		System.out.printf("%s: Consumer 2: %s\n", Thread.currentThread().getName(), item.getContent());
   		subscription.request(1);
   	}
   ```

8. onSubscribe()方法也附加一行代码请求第一个元素：

   ```java
   	@Override
   	public void onSubscribe(Flow.Subscription subscription) {
   		System.out.printf("%s: Consumer 2: Subscription received\n", Thread.currentThread().getName());
   		this.subscription=subscription;
   		subscription.request(1);
   	}
   }
   ```

9. 现在，实现名为Consumer3的类，指定其实现Item类参数化的Subscriber接口。其中onComplete()和onError()方法与前面类中的方法相同：

   ```java
   public class Consumer3 implements Flow.Subscriber<Item> {
   
   	@Override
   	public void onComplete() {
   		System.out.printf("%s: Consumer 3: Completed\n", Thread.currentThread().getName());
   	}
   	
   	@Override
   	public void onError(Throwable exception) {
   		System.out.printf("%s: Consumer 3: Error\n", Thread.currentThread().getName());
   		exception.printStackTrace(System.err);
   	}
   ```

10. 在这里onNext()方法，输出关于项的信息到控制台，但不请求任何元素：

    ```java
    	@Override
    	public void onNext(Item item) {
    		System.out.printf("%s: Consumer 3: Item received\n", Thread.currentThread().getName());
    		System.out.printf("%s: Consumer 3: %s\n", Thread.currentThread().getName(), item.getTitle());
    		System.out.printf("%s: Consumer 3: %s\n", Thread.currentThread().getName(), item.getContent());
    	}
    ```

11. 在onSubscribe()方法中，请求三个信息项：

    ```java
    	@Override
    	public void onSubscribe(Flow.Subscription subscription) {
    		System.out.printf("%s: Consumer 3: Subscription received\n", Thread.currentThread().getName());
    		System.out.printf("%s: Consumer 3: Requested three items\n", Thread.currentThread().getName());
    		subscription.request(3);
    	}
    }
    ```

12. 最后，实现包含main()方法的Main类，首先，创建三个消费者，分别对应三个类：

    ```java
    public class Main {
    
    	public static void main(String[] args) {
    		
    		Consumer1 consumer1=new Consumer1();
    		Consumer2 consumer2=new Consumer2();
    		Consumer3 consumer3=new Consumer3();
    ```

13. 现在，创建Item类参数化的SubmissionPublisher对象，使用subscribe()方法添加三个消费者：

    ```java
    		SubmissionPublisher<Item> publisher=new SubmissionPublisher<>();
    		publisher.subscribe(consumer1);
    		publisher.subscribe(consumer2);
    		publisher.subscribe(consumer3);
    ```

14. 接下来使用SubmissionPublisher对象的submit()方法创建十个Item对象，且发布这些对象，每个信息项间隔一秒钟：

    ```java
    		for (int i=0; i<10; i++) {
    			Item item =new Item();
    			item.setTitle("Item "+i);
    			item.setContent("This is the item "+i);
    			publisher.submit(item);
    			try {
    				TimeUnit.SECONDS.sleep(1);
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    		}
    ```

15. 最后，使用close()方法关闭发布者：

    ```java
    		publisher.close();
    	}
    }
    ```

### 工作原理

响应式流主要目标是提供了具有非阻塞压力的异步流处理机制。我们想要信息接收者优化其资源，因为异步机制，接收者不需要使用其资源检索新元素。当新元素进入时，将调用接收者。非阻塞压力只需要接收者准备好的时候就能使用新元素，所以能够使用有界队列来存储传入的元素，并且不会被新元素的生产者侵入。 

Java中的响应式流基于如下三个接口：

- Flow.Publisher：此接口只有一个方法：
  - subscribe()：此方法将Subscriber对象作为参数接收，发布者在发布信息项时应当考虑此订阅者。 
- Flow.Subscriber：此接口有四个方法：
  - onComplete()：当Publisher已经结束执行时，调用此方法
  - onError()：当有必须通知订阅者的错误时，调用此方法
  - onNext()：当Publisher有新元素时，调用此方法
  - onSubscribe()：当发布者使用subscribe()方法增加订阅者时，调用此方法
- Flow.Subscription：此接口有一个方法：
  - request()：通过Subscriber使用此方法，请求来自发布者的元素

因为这些只是接口，所以也可以是些这些接口来使用它们，如下所示：

1.  调用Publisher的subscribe()方法，发送一个subscriber。
2. Publisher创建Subscription对象，且发送此对象到Subscriber的onSubscribe()方法中。
3. Subscriber使用Subscription的request()方法请求元素给Publisher。
4. 当发布者有元素发布时，发布者发送元素到所有调用onNext()方法请求元素的Subscribers。
5. 当发布者结束执行时，调用订阅者的onComplete()方法。

Java API提供SubmissionPublisher类来实现发布者接口及其特性。

下图显示本范例在控制台输出的执行信息，并且能够看到响应流的特性如何按照预期展现：

![pics/06_05.jpg](pics/06_05.jpg)

三个Subscriber对象接收它们的Subscription。由于Consumer1不请求任何Item，所以不接收。Consumer3已请求三个，所以看到本范例的输出中它将接收这三个Item对象。最后，Consumer2对象将接收十个Item对象，和关于Publisher结束执行的通知。

### 扩展学习

Flow.Processor接口是应当与响应流一起使用的附加接口，和Flow.Publishe、Flow.Subscriber接口组合使用， 主要目的是作为发布者和订阅者之间的元素，将第一个发布者生成的元素转换为可以由第二个发布者处理的格式。在一个链中可以有多个处理器，因此其中一个处理器的输出可以由下一个处理器处理。 

Java还定义了Flow类，其中包括前述的四个接口。 