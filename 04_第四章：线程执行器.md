# 线程执行器

本章将学习如下内容：

- 创建线程执行器并控制其被拒任务
- 执行器中运行返回结果的任务
- 运行多任务并处理首个结果
- 运行多任务并处理所有结果
- 执行器中延迟运行任务
- 执行器中周期运行任务
- 执行器中取消任务
- 执行器中控制任务完成
- 执行器中分离任务加载和结果处理

## 引言

通常情况，当用Java开发简单的并发程序时，首先要创建Runnable对象，然后用相应的Thread对象来执行。如果需要开发大量并发任务运行的程序，此方法会有如下缺点：

- 需要实现所有与管理Thread对象相关的代码信息（创建、结束，以及得到结果）。
- 每个任务都需要创建Thread对象，执行巨量的任务会影响应用的吞吐量。
- 需要高效的控制和管理计算机资源，如果创建过多的线程，会使系统运行饱和。

自从Java5开始， Java并发API提供了一种机制，称之为**执行器框架**，目标是解决上述问题。这种机制围绕Executor接口实现，其子接口为ExecutorService，并且ThreadPoolExecutor类实现这两个接口。

此机制将任务创建和执行分离。在一个执行器中，只需要实现Runnable或者Callable对象，并发送到执行器中。执行器负责对象的执行，并使用必要的线程来运行它们。然而这种机制功能不仅仅这些，它还使用线程池来改善性能。当向执行器发送任务时，使用池化线程来执行任务，这种技术时避免持续的大量生成线程。Callable接口是Executor框架的另一个重要优势，与Runnable接口类似，但提供如下两点改善：

- call()方法，此接口的主方法，可以返回一个结果。
- 当向执行器发送Callable对象时，得到实现Future接口的对象。使用这个对象能够控制Callable对象的状态和结果。

本章用九个小节，通过使用上述Java并发API提供的类和其它变化形式，展示如何应用Executor框架进行工作。

##创建线程执行器并控制其被拒任务

应用Executor框架第一步是创建ThreadPoolExecutor类对象。使用此类提供的四个构造函数，或者名为Executors的工厂类创建ThreadPoolExecutor。一旦拥有了执行器，就可以发送Runnable或者Callable接口用来执行。

使用shutDown()方法结束执行器的运行，执行器等待或运行或等待执行的任务完成，然后结束执行。

如果在shutdown()方法和此方法执行结尾处向执行器发送任务，任务将被拒绝。这是因为执行器不再接收新任务，ThreadPoolExecutor类提供了一种机制，在任务被拒时调用。

在本节中，学习如何使用Executors类创建新的ThreadPoolExecutor对象，如何向Executor发送任务，以及如何控制Executor类的被拒任务。

### 准备工作

首先需要阅读第一章“线程管理”中“创建、运行线程，设置线程属性”小节，学习Java中线程创建的基本方法。比较两种机制，根据问题选择其中一个实现。

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 首先，实现使用服务器执行的任务，创建名为Task的类，实现Runnable接口：

   ```java
   public class Task implements Runnable{
   ```

2. 定义名为initDate的Date属性存储任务的创建日期，以及名为name的String属性存储任务名：

   ```java
   	private final Date initDate;
   	private final String name;
   ```

3. 实现类构造函数，初始化两个属性：

   ```java
       public Task(String name) {
           this.initDate = new Date();
           this.name = name;
       }
   ```

4. 实现run()方法：

   ```java
   	@Override
   	public void run() {
   ```

5. 首先，输出initDate属性和当前时间，即任务开始时间：

   ```java
   		System.out.printf("%s : Task %s : Created on :%s\n", Thread.currentThread().getName(), name ,initDate);
   		System.out.printf("%s : Task %s : Started on :%s\n", Thread.currentThread().getName(), name ,new Date());
   ```

6. 然后，设置任务随机休眠一段时间：

   ```java
   		try {
   			Long duration = (long) (Math.random() * 10);
   			System.out.printf("%s : Task %s : Doing a task during %d seconds\n", Thread.currentThread().getName(), name ,duration);
   			TimeUnit.SECONDS.sleep(duration);
   		} catch (InterruptedException e) {
   			e.printStackTrace();
   		}
   ```

7. 最后，输出任务的结束时间到控制台：

   ```java
   		System.out.printf("%s : Task %s : Finished on : %s\n", Thread.currentThread().getName(), name, new Date());
   ```

8. 创建名为RejectedTaskController的类，实现RejectedExecutionHandler接口，实现此接口的rejectedExecution方法。然后输出已被拒的任务名称，以及执行器的名称和状态：

   ```java
   public class RejectedTaskController implements RejectedExecutionHandler{
   	@Override
   	public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
   		System.out.printf("RejectedTaskController : The task %s has been rejected\n", r.toString());
   		System.out.printf("RejectedTaskController : %s\n", executor.toString());
   		System.out.printf("RejectedTaskController : Terminating : %s\n", executor.isTerminating());
   		System.out.printf("RejectedTaskController : Terminated : %s\n", executor.isTerminated());
   	}
   }
   ```

9. 使用执行器实现Server类，执行它接收的每个任务，创建名为Server的类：

   ```java
   public class Server {
   ```

10. 定义名为executor的ThreadPoolExecutor属性：

    ```java
    	private final ThreadPoolExecutor executor;
    ```

11. 实现类构造函数，使用Executors类初始化ThreadPoolExecutor对象，为被拒任务建立处理器：

    ```java
    	public Server() {
    		this.executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    		RejectedTaskController controller = new RejectedTaskController();
    		executor.setRejectedExecutionHandler(controller);
    	}
    ```

12. 实现executeTask()方法，将Task对象作为参数接收并发送给执行器。首先，输出信息指明新的任务已到达：

    ```java
    	public void executeTask(Task task) {
    		System.out.printf("Server : A new task has arrived\n");
    ```

13. 然后，调用执行器的execute()方法，并发送给任务：

    ```java
    		executor.execute(task);
    ```

14. 最后，输出执行器数据到控制台，观察其状态：

    ```java
    		System.out.printf("Server : Pool Size : %d\n", executor.getPoolSize());
    		System.out.printf("Server : Active Count : %d\n", executor.getActiveCount());
    		System.out.printf("Server : Task Count : %d\n", executor.getTaskCount());
    		System.out.printf("Server : Complete Tasks :%d\n", executor.getCompletedTaskCount());
    	}
    ```

15. 接下来，实现endServer()方法，在这个方法中，调用执行器的shutdown()方法结束其执行：

    ```java
    	public void endServer() {
    		executor.shutdown();
    	}
    ```

16. 实现范例的主方法，创建一个包含main()方法的Main类。首先，创建100个任务发送到Executor：

    ```java
    public class Main {
    	public static void main(String[] args) {
    		Server server = new Server();
    		
    		System.out.printf("Main : Starting.\n");
    		for( int i = 0 ; i <100 ; i++) {
    			Task task = new Task("Task " + i);
    			server.executeTask(task);
    		}
    ```

17. 然后调用Server的endServer()方法，关闭执行器：

    ```java
    		System.out.printf("Main : Shuting down the Executor.\n");
    		server.endServer();
    ```

18. 最后，发送新任务，此任务将被拒绝，所以将会观察到此机制工作情况：

    ```java
    		System.out.printf("Main : Sending another Task.\n");
    		Task task = new Task("Rejected task");
    		server.executeTask(task);
    		
    		System.out.printf("Main : End.\n");
    	}
    ```

### 工作原理

范例关键点是Server类，此类创建和使用ThreadPoolExecutor来执行任务。

第一个重点是在Server类构造函数中的ThreadPoolExecutor创建。ThreadPoolExecutor类有四个不同的构造函数，然而因为其复杂度，Java并发API提供Executors类来构造执行器和其它相关对象。虽然可以使用Server类其中一个构造函数直接创建ThreadPoolExecutor，但是推荐使用Executors类。

这种情况下， 为了创建构造器，使用Executors类的newFixedThreadPool()方法创建缓存线程池。此方法创建具有最多数量线程的执行器，如果发送的任务数比此数量还多，剩余的任务将被阻塞直到有可用的空闲线程来处理它们。此方法将执行器中最多的线程数量作为参数接收。本范例中，我们使用Runtime类的availableProcessors()方法返回Java虚拟机可用的处理器数量，通常和计算机的处理器核心个数相等。

线程重复利用的优点是减少创建线程消耗的时间。但是缓存线程池的缺点是为了新的任务而一直保持空置线程。所以，如果向执行器中发送过多的任务，系统会超载。

一旦创建执行器，即可使用execute()方法发送Runnable或者Callable类型的任务用来执行。这种情况下，发送Task类的对象来实现Runnable接口。

也可以输出关于执行器情况的日志信息，明确使用如下方法：

- getPoolSize()：此方法返回执行器线程池中的实际线程数。
- getActiveCount()：此方法返回正在执行器中运行任务的线程数。
- getTaskCount()：此方法返回计划执行的任务数，返回值因为动态改变，只是一个近似值。
- getCompletedTaskCount()：此方法返回通过执行器完成的任务数。

通常对于ThreadPoolExecutor类和执行器的关键点是必须明确终止它们，如果不这样做，执行器会继续执行并且程序无法结束。如果执行器没有任务去执行，它将继续等待新的任务而不是终止执行。Java应用在所有非守护线程完成执行之前是不会结束的，所以如果不终止执行器，应用将永不结束。

使用ThreadPoolExecutor类的shutdown()方法表明结束指定执行器。当执行器完成所有待定任务的执行时，它也终止运行。调用shutdown()方法之后，如果尝试发送另一个任务到执行器，将被拒绝且执行器会抛出RejectedExecutionException异常，除非像本范例中，已经实现了被拒任务的管理者。为了管理执行器中的被拒任务，需要创建实现RejectedExecutionHandler接口的类，此接口的rejectedExecution()方法包含两个参数：

- Runnable对象存储已经被拒绝的任务
- Executor对象存储拒绝任务的执行器

下图显示本范例在控制台输出的部分执行信息：

![pics/04_01.jpg](pics/04_01.jpg)

可以看到当最后一个任务到达执行器时，池中的线程个数和正在执行的线程数均显示为4，这是根据运行范例的计算机处理器核心数得到的，即availableProcessors()方法返回的数字。一旦运行完成，关闭执行器并且下一个任务被拒绝。RejectedTaskController输出任务和执行器信息到控制台。

### 扩展学习

Executors还提供其它方法来创建ThreadPoolExecutor：

- newCachedThreadPool()：此方法返回ExecutorService对象，所以被映射到ThreadPoolExecutor具有其所有方法的访问权。如果需要的话，已创建的缓存线程池开始创建新的线程来执行新任务。此外，如果线程运行的任务已经完成执行，重新使用这些线程。
- newSingleThreadExecutor()：这是固定数量的线程执行器的极端情况，只创建带有一个线程的执行器，所以它在同一时间只能执行一个任务。

ThreadPoolExecutor类提供很多方法得到其状态信息。范例中使用getPoolSize()、getActiveCount()和getCompletedTaskCount()方法得到线程池大小、线程数和执行器完成任务数信息。也可以使用getLargestPoolSize()方法，返回某时刻线程池中有最多线程的数量。

ThreadPoolExecutor也提供其它与执行器终止的方法，如下所示：

- shutdownNow()：立即停止执行器，不再执行待定任务，此方法返回所有待定任务列表。在调用此方法时，正在运行的任务将继续完成执行，然而此方法不等待它们终止。
- isTerminated()：此方法在调用shutdown()或者shutdownNow()方法时均返回true，执行器相应地进行关闭过程。
- isShutdown()：此方法在调用执行器的shutdown()方法时返回true。
- awaitTermination(long timeout, TimeUnit unit)：此方法阻塞调用线程，直到执行器的任务结束或者已过指定的时间。TimeUnit是一个枚举类型的类，包含如下常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS、和SECONDS。

> 如果为了等待任务完成，不用考虑其持续时间，使用大的时间延迟，例如DAYS。

### 更多关注

- 第九章“测试并发应用”中的“监控Executor框架”小节。

## 执行器中运行返回结果的任务

Executor框架的优点是支持运行返回值的并发任务，Java并发API使用如下两个接口实现此功能：

- Callable：此接口具有call()方法，在此方法中，需要实现任务逻辑。Callable接口是参数化接口，意思是需要指明call方法将要返回的数据类型。
- Future：此接口具有一些方法，用来得到通过Callable对象生成的结果，且管理其状态。

本节中，学习如何实现返回结果并且在执行器上运行的任务。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 创建名为FactorialCalculator的类，指定其实现具有Integer类型参数化的Callable接口：

   ```java
   public class FactorialCalculator implements Callable<Integer> {
   ```

2. 定义名为number的私有Integer属性，用来存储此任务用来计算的数字：

   ```java
   	private final Integer number;
   ```

3. 实现类构造函数，初始化类属性：

   ```java
   	public FactorialCalculator(Integer number){
   		this.number=number;
   	}
   ```

4. 实现call()方法，此方法返回FactorialCalculator的数字属性阶乘：

   ```java
   	@Override
   	public Integer call() throws Exception {
   ```

5. 首先，创建和初始化方法中用到的内部参数：

   ```java
   		int result = 1 ;
   ```

6. 如果数字是0或者1，返回1，否则，计算数字阶乘。为了教学目的，在两个乘法之间，设置此任务休眠20毫秒：

   ```java
   		if((number == 0) || (number == 1)) {
   			result = 1;
   		} else {
   			for( int i = 2 ; i  <= number ; i ++) {
   				result *= 1;
   				TimeUnit.MILLISECONDS.sleep(20);
   			}
   		}
   ```

7. 输出结果信息到控制台：

   ```java
   		System.out.printf("%s : %d\n", Thread.currentThread().getName(), result);
   ```

8. 返回操作结果：

   ```java
   		return result;
   ```

9. 实现范例的主方法，创建一个包含main()方法的Main类：

   ```java
   public class Main {
   	public static void main(String[] args) {
   ```

10. 使用Executors类的newFixedThreadPool()方法创建ThreadPoolExecutor来运行任务。将2作为参数传递，也就是执行器中的线程数：

    ```java
    		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);
    ```

11. 创建Future<Integer>对象列表：

    ```java
    		List<Future<Integer>> resultList = new ArrayList<>();
    ```

12. 使用Random类创建随机数字生成器：

    ```java
    		Random random = new Random();
    ```

13. 创建重复10次的循环，每次循环中，生成一个随机数：

    ```java
    		for( int i = 0 ; i <10 ; i ++) {
    			Integer number = random.nextInt(10);
    ```

14. 然后，创建FactorialCalculator对象，将生成的随机数作为参数传递：

    ```java
    			FactorialCalculator calculator = new FactorialCalculator(number);
    ```

15. 调用执行器的submit()方法传递FactorialCalculator任务到执行器，此方法返回Future<Integer>对象来管理任务，并最终得到结果：

    ```java
    			Future<Integer> result = executor.submit(calculator);
    ```

16. 在之前创造的列表中加入Future对象：

    ```java
    			resultList.add(result);
    		}
    ```

17. 创建do循环用来监控执行器的状态：

    ```java
    		do {
    ```

18. 首先，使用执行器的getCompletedTaskCount()方法，输出指明完成的任务数量信息到控制台：

    ```java
    			System.out.printf("Main : Number of Completed Tasks : %d\n", executor.getCompletedTaskCount());
    ```

19. 然后，循环列表中的10个Future对象，使用isDone()方法，输出指明其管理的任务是否完成的信息：

    ```java
    			for ( int i =0 ; i <resultList.size() ; i ++ ) {
    				Future<Integer> result = resultList.get(i);
    				System.out.printf("Main : Task %d :%s\n", i ,result.isDone());
    			}
    ```

20. 设置线程休眠50毫秒：

    ```java
    			try {
    				TimeUnit.MILLISECONDS.sleep(50);
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    ```

21. 当执行器中完成的任务数量小于10时，重复此循环：

    ```java
    		} while (executor.getCompletedTaskCount() < resultList.size());
    ```

22. 在控制台中，输出每次任务得到的结果。循环每个Future对象，通过使用get()方法得到任务返回的Integer对象：

    ```java
    		System.out.printf("Main : Results\n");
    		for( int i = 0 ; i < resultList.size(); i ++) {
    			Future<Integer> result = resultList.get(i);
    			Integer number = null;
    			try {
    				number = result.get();
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			} catch (ExecutionException e) {
    				e.printStackTrace();
    			}
    ```

23. 然后，打印数量到控制台：

    ```java
    			System.out.printf("Main : Task %d : %d\n", i , number);
    		}
    ```

24. 最后，调用执行器的shutdown()对象终止其执行：

    ```java
    		executor.shutdown();
    ```

###工作原理

在本节中，学习了如何使用Callable接口加载返回结果的并发任务。通过FactorialCalculator类实现Callable接口，包含Integer类型的结果。因此，call()方法返回一个Integer值。

范例中另一个关键点是Main类，通过使用submit()方法发送将在执行器中运行的Callable对象，这个方法将Callable对象作为参数接收，并且返回Future对象，来达到两个目的：

- 控制任务的状态。可以取消任务，检查任务是否完成。为此，需使用isDone()方法。
- 通过使用get()方法，获得call()方法返回的结果。此方法指导Callable对象已经完成call()方法的执行并且返回结果之后才运行。如果线程在get()方法等到返回结果时被中断，则抛出InterruptedException 异常。如果call()方法抛出异常，get()方法就会抛出ExecutionException异常。

### 扩展学习

当调用Future对象的get()方法，并且此对象控制的任务还没有完成时，方法则被阻塞直到任务完成。Future接口提供了get()方法的另一种形式：

- get(long timeout, TimeUnit unit)：在这个方法中，如果任务的结果无效，则等待指定的时间，如果已过指定时间且结果依然无效，此方法就会抛出TimeoutException 异常。TimeUnit是一个枚举类型的类，包含如下常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS、和SECONDS。

### 更多关注

- 本章“创建线程执行器并控制其被拒任务”，“运行多任务并处理首个结果”，和“运行多任务并处理所有结果”小节

## 运行多任务并处理首个结果

当使用多种有效的并发任务解决问题时，会产生一个普遍的问题，那就是只需要第一个结果。例如，想要排列数组，可以使用各种各样的排列算法。也就是说，对指定的数组用最快的排序算法进行排序，然后从排好序的数组中找到第一个结果。

本节中，学习使用ThreadPoolExecutor类来实现这个场景。使用两种机制来尝试并确认一个用户。当其中一种机制能够确认的话，此用户则被认证通过。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 创建名为UserValidator的类，实现用户认证过程：

   ```java
   public class UserValidator {
   ```

2. 定义名为name的私有String属性，用来存储用户认证系统的用户名：

   ```java
   	private final String name;
   ```

3. 实现类构造函数，初始化属性：

   ```java
   	public UserValidator(String name) {
   		this.name = name;
   	}
   ```

4. 实现validate()方法，接收两个String参数，分别是需要认证的用户名和用户密码：

   ```java
   	public boolean validate(String name , String password) {
   ```

5. 创建名为random的Random对象：

   ```java
   		Random random = new Random();
   ```

6. 随机等待一段时间来模拟用户认证过程：

   ```java
   		try {
   			long duration = (long) (Math.random() * 10);
   			System.out.printf("Validator %s : Validating a user during %d seconds\n", this.name, duration);
   			TimeUnit.SECONDS.sleep(duration);
   		} catch (InterruptedException e) {
   			return false;
   		}
   ```

7. 返回随机的Boolean值，当用户认证通过时，validate()方法返回true，否则false：

   ```java
   		return random.nextBoolean();
   	}
   ```

8. 实现getName()方法，返回名字的属性值：

   ```java
   	public String getName() {
   		return name;
   	}
   ```

9. 现在，创建名为ValidatorTask的类，使用UserValidation对象作为并发任务，来执行认证过程。指定其实现String类参数化的Callable接口：

   ```java
   public class ValidatorTask implements Callable<String>{
   ```

10. 定义名为validator的私有UserValidator属性：

    ```java
    	private final UserValidator validator;
    ```

11. 定义两个私有String属性，分别是user和password：

    ```java
    	private final String user;
    	private final String password;
    ```

12. 实现类构造函数，初始化这些属性：

    ```java
    	public ValidatorTask(UserValidator validator, String user, String password) {
    		this.validator = validator;
    		this.user = user;
    		this.password = password;
    	}
    ```

13. 实现call()方法，返回String对象：

    ```java
    	@Override
    	public String call() throws Exception {
    ```

14. 如果用户未通过UserValidator对象认证，输出对应信息到控制台并且抛出Exception：

    ```java
    		if(!validator.validate(user, password)) {
    			System.out.printf("%s : The user has not been found\n", validator.getName());
    			throw new Exception("Error validating user");
    		}
    ```

15. 否则，输出信息到控制台知名用户已认证通过，并返回UserUserValidator对象的名称：

    ```java
    		System.out.printf("%s : The user has been found\n", validator.getName());
    		return validator.getName();
    	}
    ```

16. 现在实现范例的主方法，创建一个包含main()方法的Main类：

    ```java
    public class Main {
    	public static void main(String[] args) {
    ```

17. 创建两个名为user和password的String对象，初始化测试值：

    ```java
    		String username = "test";
    		String password = "test";
    ```

18. 创建两个UserValidator对象，名为ldapValidator和dbValidator：

    ```java
    		UserValidator ldapValidator = new UserValidator("LDAP");
    		UserValidator dbValidator = new UserValidator("DataBase");
    ```

19. 创建两个名为ldapTask和dbTask的TaskValidator对象，分别用ldapValidator和dbValidator初始化：

    ```java
    		ValidatorTask ldapTask = new ValidatorTask(ldapValidator, username, password);
    		ValidatorTask dbTask = new ValidatorTask(dbValidator, username, password);
    ```

20. 创建TaskValidator对象列表，将已创建的两个对象添加进去：

    ```java
    		List<ValidatorTask> taskList = new ArrayList<>();
    		taskList.add(ldapTask);
    		taskList.add(dbTask);
    ```

21. 使用Executors类的newCachedThreadPool()方法创建新的ThreadPoolExecutor对象，以及名为result的字符串变量：

    ```java
    		ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();
    		String result;
    ```

22. 调用执行器对象的invokeAny()方法，这个方法将taskList 作为参数接收且返回String。同样的，将返回的String对象输出到控制台：

    ```java
    		try {
    			result = executor.invokeAny(taskList);
    			System.out.printf("Main : Result : %s\n", result);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		} catch (ExecutionException e) {
    			e.printStackTrace();
    		}
    ```

23. 使用shutdown()方法终止执行器，输出程序已结束的信息到控制台： 

    ```java
    		executor.shutdown();
    		System.out.printf("Main : End of the Execution\n");
    ```

### 工作原理

本范例的关键点在Main类中，ThreadPoolExecutor类的invokeAny()方法接受任务队列，然后加载任务队列，并且返回首个任务结果，不抛出异常。此方法返回与任务的call()方法返回的数据类型相同。这种情况下，返回String值。

下图显示本范例在控制台输出一个任务认证用户的执行信息：

![pics/04_02.jpg](pics/04_02.jpg)

范例包括两个UserValidator对象返回随机布尔型值，每个UserValidator对象被TaskValidator类实现的Callable对象使用。如果UserValidator类的validate()方法放回fasle值，TaskValidator类抛出异常，否则返回true。

所以，有两个任务能够返回true值或者抛出异常，出现以下四种可能：

- 两个任务均返回true值。invokeAny()方法的结果是在第一个完成的任务名称。
- 第一个任务返回true，第二个任务抛出Exception。invokeAny()方法的结果是第一个任务的名称。
- 第一个任务抛出Exception，第二个返回true值。nvokeAny()方法的结果是第二个任务的名称。
- 两个任务均抛出Exception。这种情况下，invokeAny()方法抛出ExecutionException异常。


如果多次运行此范例，四个可能的结果都可能得到。

下图显示当两个任务抛出异常时，本范例在控制台的输出信息：

![pics/04_03.jpg](pics/04_03.jpg)

### 扩展学习

ThreadPoolExecutor类提供了invokeAny()方法的另一种形式：

- invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) ：如果未过指定时间，此方法执行所有的任务，且返回不抛出异常完成的第一个结果。TimeUnit是一个枚举类型的类，包含如下常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS、和SECONDS。

### 更多关注

- 本章“运行多任务并处理所有结果”小节。

## 运行多任务并处理所有结果

Executor框架执行并发任务，无需考虑线程创建和执行。通过使用提供的Future类，用来在执行器中控制所有运行的任务状态，并且得到结果。

当想要等待任务的终止时，可以使用如下两个方法：

- Future接口的isDone()方法，如果任务已经完成执行，返回true
- ThreadPoolExecutor类的awaitTermination()方法，设置线程休眠直到所有任务在调用shutdown()方法之后已经完成执行

这两个方法有一些缺点。第一个方法只能控制任务的完成。第二个方法，需要关闭执行器等待线程，否则，此方法理解返回。

ThreadPoolExecutor类提供了一个方法，将任务列表传送到执行器，然后等待列表中所有任务完成。在本节中，学习如何使用这个特性实现范例，当10个任务已经执行完成时，打印输出它们的结果。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 创建名为Result的类，存储本范例并发任务中生成的结果：

   ```java
   public class Result {
   ```

2. 定义两个私有属性，名为name的String属性，名为value的int属性：

   ```java
   	private String name;
   	private int value;
   ```

3. 实现对应的get()和set()方法，设置和返回两个属性的值：

   ```java
   	public String getName() {
   		return name;
   	}
   	public void setName(String name) {
   		this.name = name;
   	}
   	public int getValue() {
   		return value;
   	}
   	public void setValue(int value) {
   		this.value = value;
   	}
   ```

4. 创建名为Task的类，实现通过Result类参数化的Callable接口：

   ```java
   public class Task implements Callable<Result>{
   ```

5. 定义名为name的私有String属性：

   ```java
   	private final String name;
   ```

6. 实现类构造函数，初始化属性：

   ```java
   	public Task(String name){
   		this.name = name;
   	}
   ```

7. 实现类的call()方法，这种情况下，方法将返回Result对象：

   ```java
   	@Override
   	public Result call() throws Exception {
   ```

8. 首先，在控制台输出一条表明任务将要开始的信息：

   ```java
   		System.out.printf("%s : Starting\n", this.name);
   ```

9. 然后，随机等待一段时间：

   ```java
   		try {
   			long duration = (long)(Math.random() * 10);
   			System.out.printf("%s : Waiting %d seconds for results.\n", this.name, duration);
   			TimeUnit.SECONDS.sleep(duration);
   		}catch (InterruptedException e) {
   			e.printStackTrace();
   		}
   ```

10. 为了生成在Result对象中被返回的int值，计算五个随机数字的和：

    ```java
    		int value = 0;
    		for (int i = 0 ; i < 5 ; i ++) {
    			value += (int)(Math.random()*100);
    		}
    ```

11. 创建Result对象，用Task对象名称和上一步操作的结果进行初始化：

    ```java
    		Result result=new Result();
    		result.setName(this.name);
    		result.setValue(value);
    ```

12. 输出指明任务已经完成的信息到控制台：

    ```java
    		System.out.printf(this.name + " : Ends\n");
    ```

13. 返回Result对象：

    ```java
    		return result;
    ```

14. 最后，实现范例的主方法，创建一个包含main()方法的Main类：

    ```java
    public class Main {
    	public static void main(String[] args) {
    ```

15. 使用Executors类的newCachedThreadPool()方法创建ThreadPoolExecutor对象：

    ```java
    		ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();
    ```

16. 创建Task对象列表，然后创建10个Task对象，保存到列表中：

    ```java
    		List<Task> taskList = new ArrayList<>();
    		for(int i = 0 ; i < 10 ; i ++){
    			Task task = new Task("Task-" + i);
    			taskList.add(task);
    		}
    ```

17. 创建Future对象列表，通过Result类参数化：

    ```java
    		List<Future<Result>> resultList = null;
    ```

18. 调用ThreadPoolExecutor类的invokeAll()方法，将返回上一步的Future对象列表：

    ```java
    		try {
    			resultList = executor.invokeAll(taskList);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    ```

19. 使用shutdown()方法结束执行：

    ```java
    		executor.shutdown();
    ```

20. 输出任务处理Future对象列表的结果到控制台：

    ```java
    		System.out.printf("Main : Printing the results");
    		for (int i = 0 ; i < resultList.size() ; i ++){
    			Future<Result> future =resultList.get(i);
    			Result result;
    			try {
    				result = future.get();
    				System.out.printf(result.getName() + " : " + result.getValue() + "\n");
    			} catch (InterruptedException | ExecutionException e) {
    				e.printStackTrace();
    			}
    		}
    ```

### 工作原理

在本节中，学习如何发送任务列表到执行器，以及使用invokeAll()方法等到所有任务的终止。这个方法接收Callable对象列表，并返回Future对象列表，此列表给每个Future对象分配一个任务。Future对象列表中的第一个对象控制Callable对象列表中的第一个热为奴，第二个对象控制第二个任务，以此类推。

需要考虑的一点是，在定义存储结果对象的列表中， 用来Future接口参数化的数据类型必须与Callable对象参数的数据类型同构。本范例中，就是使用相同的数据类型：Result类。

关于invokeAll()方法的另一个重点是使用Future对象只用来得到任务结果。当所有任务结束时，方法也结束，如果调用返回的Future对象的isDone()方法，那么所有的调用均返回true值。

### 扩展学习

ExecutorService类提供了invokeAll()方法的另一种形式：

- invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) ：如果未过指定时间，当所有任务结束时，此方法执行所有的任务且返回它们的执行结果。TimeUnit是一个枚举类型的类，包含如下常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS、和SECONDS。

### 更多关注

本章“执行器中运行返回结果的任务”和“运行多任务并处理首个结果”小节。

## 执行器中延迟运行任务

Executor框架提供ThreadPoolExecutor类使用线程池来运行Callable和Runnable任务，以避免所有线程创建操作。当发送任务到执行器时，根据执行器的配置迅速执行。有些实际情况是不需要迅速执行任务的，例如可能在一定时间之后执行或者周期运行任务。为此，执行器框架提供了ScheduledThreadPoolExecutor类实现的ScheduledExecutorService接口。

本节中，讲学习如何创建ScheduledThreadPoolExecutor，并且用来在给定一段时间之后计划任务执行。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 创建名为Task的类，实现参数为String类的Callable接口：

   ```java
   public class Task implements Callable<String> {
   ```

2. 定义名为name的私有String属性，存储任务名称：

   ```java
   	private final String name;
   ```

3. 实现类构造函数，初始化名称属性：

   ```java
   	public Task(String name){
   		this.name = name;
   	}
   ```

4. 实现call()方法，输出当前时间以及返回一些文本到控制台，例如，你好，世界：

   ```java
   	@Override
   	public String call() throws Exception {
   		System.out.printf("%s : Starting at : %s\n", name, new Date());
   		return "Hello, world";
   	}
   ```

5. 实现范例的主方法，创建一个包含main()方法的Main类：

   ```java
   public class Main {
   	public static void main(String[] args) {
   ```

6. 使用Executors类的newScheduledThreadPool()方法创建ScheduledThreadPoolExecutor类的执行器，传参值1：

   ```java
   		ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
   ```

7. 使用ScheduledThreadPoolExecutor实例的schedule()方法初始化和启动一些任务（本范例中是五个）：

   ```java
   		System.out.printf("Main : Starting at : %s\n", new Date());
   		for (int i = 0 ; i < 5 ; i ++){
   			Task task = new Task("Task " + i);
   			executor.schedule(task, i+1, TimeUnit.SECONDS);
   		}
   ```

8. 使用shutdown()方法请求执行器终止：

   ```java
   		executor.shutdown();
   ```

9. 使用执行器的awaitTermination()方法等待所有任务的终止：

   ```java
   		try {
   			executor.awaitTermination(1, TimeUnit.DAYS);
   		} catch (InterruptedException e) {
   			e.printStackTrace();
   		}
   ```

10. 输出指明程序将要结束的信息到控制台：

    ```java
    		System.out.printf("Main : Ends at : %s\n", new Date());
    ```

### 工作原理

本范例的关键点是Main类和ScheduledThreadPoolExecutor管理。因为使用ThreadPoolExecutor类创建定时执行器，Java要求使用Executors类。本范例中，用到了newScheduledThreadPool()方法，将数字1作为参数传到此方法，这个参数是线程池中线程的数量。

为了一段时间过后，在定时执行器中执行任务，需要使用schedule()方法。此方法接收如下三个参数：

- 想要执行的任务
- 在任务执行之前需要等待的时间段
- 时间段的单位，规定为TimeUnit类的常量

这种情况下，每个任务等待的秒长（TimeUnit.SECONDS）等于其在任务队列中的位置加1。

> 如果想要在指定时间执行任务，计算此时间与当前时间的差异，作为任务的延迟时间。

下图显示本范例在控制台输出的执行信息：

![pics/04_04.jpg](pics/04_04.jpg)

可以看到任务如何每隔一秒开始执行。所有任务在同一时刻传到执行器，但每个任务延迟先前任务1秒执行。

### 扩展学习

也可以使用Runnable接口实现任务，因为ScheduledThreadPoolExecutor类的schedule()方法允许这两种任务类型：

虽然ScheduledThreadPoolExecutor类是ThreadPoolExecutor类的子类（所以继承其所有特性），但Java要求只对定时任务使用ScheduledThreadPoolExecutor。

最后，当调用shutdown()方法，且有等待延迟时间结束的待定线程时，则可以配置ScheduledThreadPoolExecutor类的特性。默认特性是这些线程将被执行，而不考虑执行器终止。通过使用ScheduledThreadPoolExecutor类的setExecuteExistingDelayedTasksAfterShutdownPolicy()方法改变这个特性。如果调用setExecuteExistingDelayedTasksAfterShutdownPolicy()方法传参false值，待定线程在调用shutdown()方法后不会被执行。

### 更多关注

本章“执行器中运行返回结果的任务”小节。

## 执行器中周期运行任务

执行器框架提供ThreadPoolExecutor类使用线程池来执行并发任务，以避免所有线程创建操作。当发送任务到执行器时，根据执行器的配置迅速执行。当结束时，任务从执行器中删除，如果想再次运行，就需要再次发送任务到执行器中。

然而，执行器框架通过ScheduledThreadPoolExecutor类提供周期运行任务的可行性。本节中，讲学习如何使用此类的功能计划周期任务。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 创建名为Task的类，实现Runnable接口：

   ```java
   public class Task implements Runnable {
   ```

2. 定义名为name的私有String属性，存储任务名称：

   ```java
   	private final String name;
   ```

3. 实现类构造函数，初始化属性：

   ```java
   	public Task(String name){
   		this.name = name;
   	}
   ```

4. 实现run()方法，输出当前时间的信息到控制台，指明任务将在特定周期内执行：

   ```java
   	@Override
   	public void run() {
   		System.out.printf("%s : Executed at : %s\n", name, new Date());
   	}
   ```

5. 实现范例的主方法，创建一个包含main()方法的Main类：

   ```java
   public class Main {
   	public static void main(String[] args) {
   ```

6. 使用Executors类的newScheduledThreadPool()方法创建ScheduledExecutorService，传参值1：

   ```java
   		ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
   ```

7. 输出当前时间到控制台：

   ```java
   		System.out.printf("Main : Starting at : %s\n", new Date());
   ```

8. 创建新的Task对象：

   ```java
   		Task task = new Task("Task");
   ```

9. 使用scheduledAtFixRate()方法传递对象到执行器。使用上一步创建的任务作为参数：数字1，数字2，以及TimeUnit.SECONDS常量。此方法返回ScheduledFuture对象用来控制任务状态：

   ```java
   		ScheduledFuture<?> result =executor.scheduleAtFixedRate(task, 1, 2, TimeUnit.SECONDS);
   ```

10. 创建循环重复10次输出任务下一次执行持续的时间。在循环中，使用ScheduledFuture对象的getDelay()方法在任务下一次执行之前，获得毫秒数：

    ```java
    		for (int i = 0 ; i < 10 ; i ++){
    			System.out.printf("Main : Delay : %d\n", result.getDelay(TimeUnit.MILLISECONDS));
    ```

11. 休眠线程500毫秒：

    ```java
                try {
                    TimeUnit.MILLISECONDS.sleep(500);
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
    		}	
    ```

12. 使用shutdown()方法结束执行器：

    ```java
    		executor.shutdown();
    ```

13. 设置线程休眠5秒来证明周期任务已经完成：

    ```java
    		try {
    			TimeUnit.SECONDS.sleep(5);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    ```

14. 输出指明程序结束的信息到控制台：

    ```java
    		System.out.printf("Main : Finished at : %s\n", new Date());
    ```

### 工作原理

在使用执行器框架运行周期任务时，需要使用ScheduledExecutorService类。为了创建此对象（对每个执行器来说），Java要求使用Executors类，相当于executor对象的工厂类。这种情况下，使用newScheduledThreadPool()方法创建ScheduledExecutorService对象。此对象将线程池中线程数量作为参数接收，因为本范例中只有一个任务，所以传参值为1。

一旦执行器需要运行周期任务，使用scheduleAtFixedRate()方法发送任务到执行器。此方法接受四个参数：周期运行的任务，任务第一次执行的延迟时间，两次执行间的周期，第二和第三个参数的时间单位，是一个枚举类型的类，包含如下常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS、和SECONDS。

需要注意的重点是两次执行之间的时间是启动这两个执行任务的时间间隔。如果一个周期任务需要5秒后开始执行，而任务的周期间隔是3秒，则需要同时定义两个任务执行实例。

scheduledAtFixedRate()方法返回继承Future接口的ScheduledFuture对象，包含处理计划任务的方法。ScheduledFuture是参数化接口，本范例中，因为任务是未参数化的Runnable对象，需要使用?标识作为参数来进行参数化。

范例中用到ScheduledFuture接口的getDelay()方法，返回直到下一个任务执行的时间。此方法接收TimuUnit常量，包含想要接收结果的时间单位。

下图显示本范例在控制台输出的执行信息：

![pics/04_05.jpg](pics/04_05.jpg)

任务每个两秒执行一次（通过Task前缀定义）且延迟500毫秒输出到控制台，即设置主线程休眠的时长。当关闭执行器时，计划任务终止运行，控制台上将不显示任何信息。

### 扩展学习

ScheduledThreadPoolExecutor提供scheduleWithFixedRate()方法来安排周期任务，此方法与scheduledAtFixedRate()方法参数相同，然而值得注意的不同点是，scheduledAtFixedRate()方法的第三个参数确定两个任务开始执行的周期时间。而scheduleWithFixedRate()方法的第三个参数确定是任务结束与下一个任务开始的周期时间。

通过shutdown()方法配置ScheduledThreadPoolExecutor类实例的特性，实例默认特性是计划任务在调用此方法时结束，通过使用ScheduledThreadPoolExecutor类的setContinueExistingPeriodicTasksAfterShutdownPolicy()方法传递true值来配置实例特性，在调用shutdown()方法之前，周期任务不会结束。

### 更多关注

- 本章“创建线程执行器并控制其被拒任务”和”执行器中延迟运行任务“小节。

## 执行器中取消任务

当用执行器开发时，不需要管理线程，只要实现Runnable或Callable任务且发送给执行器。执行器的任务是创建线程，在线程池中管理线程，如果不需要的话则结束线程。有时可能会取消发送给执行器的任务，这种请款下， 使用Future的cancel()方法，允许你进行取消操作。本届中，学习如何使用此方法取消已经发送到执行器的任务。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 创建名为Task的类，实现String类参数化的Callable接口。实现call()方法，在一个无限循环中输出信息到控制台并设置其休眠100毫秒：

   ```java
   public class Task implements Callable<String>{
   	@Override
   	public String call() throws Exception {
   		while(true) {
   			System.out.printf("Task : Test\n");
   			Thread.sleep(100);
   		}
   	}

   }
   ```

2. 实现范例的主方法，创建一个包含main()方法的Main类：

   ```java
   public class Main {
   	public static void main(String[] args) {
   ```

3. 使用Executors类的newCachedThreadPool()方法创建ThreadPoolExecutor对象：

   ```java
   		ThreadPoolExecutor executor = (ThreadPoolExecutor)Executors.newCachedThreadPool();
   ```

4. 创建新的Task对象：

   ```java
   		Task task = new Task();
   ```

5. 使用submit()方法发送任务到执行器：

   ```java
   		System.out.printf("Main : Executing the Task\n");
   		Future<String> result =executor.submit(task);
   ```

6. 设置主任务休眠2秒钟：

   ```java
   		try {
   			TimeUnit.SECONDS.sleep(2);
   		} catch (InterruptedException e) {
   			e.printStackTrace();
   		}
   ```

7. 使用Future对象的cancel()方法取消任务执行，这个Future对象名为result，通过submit()方法返回，cancel()方法传参数true：

   ```java
   		System.out.printf("Main : Canceling the Task\n");
   		result.cancel(true);
   ```

8. 输入调用isCancelled()和isDone()方法得到的结果到控制台，用来核实任务已经被取消，即已经完成：

   ```java
   		System.out.printf("Main : Canceled : %s\n", result.isCancelled());
   		System.out.printf("Main : Done : %s\n", result.isDone());
   ```

9. 使用shutdown()方法结束执行器，输出指明程序结束的信息到控制台：

   ```java
   		executor.shutdown();
   		System.out.printf("Main : The executor has finished\n");
   ```

### 工作原理

当需要取消已经发送到执行器的任务时，使用Future接口的cancel()方法。此方法的特性取决于传参值和任务状态的变化而不同：

- 如果任务已经完成或者之前已经被取消，或者因为其他任何原因而无法取消，此方法返回false值，且任务无法被取消。
- 如果任务在执行器中等待获得执行它的Thread对象，此任务将被取消且永不会执行。如果任务已经运行，则取决于此方法的参数。cancel()方法接受布尔值作为参数，如果参数值是true且任务正在运行，则将被取消。如果参数值是false且任务正在运行，则不会被取消。

下图显示本范例在控制台输出的执行信息：

![pics/04_06.jpg](pics/04_06.jpg)

### 扩展学习

如果使用Future对象的get()方法控制已经被取消的任务，get()方法将抛出CancellationException异常。

### 更多关注

本章“执行器中运行返回结果的任务“小节。

##执行器中控制任务完成

Java API提供FutureTask类作为一种可撤销异步计算，此类实现了Runnable和Future接口并提供Future接口的基础实现。通过使用Callable或Runnable（Runnable对象不返回结果，所以假若Future对象返回结果的话，就需要传参）对象创建FutureTask类。此类提供取消执行以及获得计算结果的方法，还提供名为done()的方法允许在执行器中的任务运行完成后再执行一些代码。此类用来进行后处理操作，例如生成报告，通过电子邮件发送结果，或者释放资源。当FutureTask对象正在控制的任务执行完成时，done()方法被FutureTask类内部调用。此方法在任务结果被设置并且其状态变为isDone之后调用，而不考虑任务是否已经被正常地取消或者结束。

默认情况下，此方法为空，通过重写FutureTask类和实现此方法改变特性。在本节中，学习如何重写此方法在任务执行之后运行代码。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 创建名为ExecutableTask的类，实现String类参数化的Callable接口：

   ```java
   public class ExecutableTask implements Callable<String>{
   ```

2. 定义名为name的私有String属性，存储任务名称。实现getName()方法，返回属性值：

   ```java
   	private final String name;
   	public String getName() {
   		return name;
   	}
   ```

3. 实现类构造函数，初始化任务名称：

   ```java
   	public ExecutableTask(String name){
   		this.name = name;
   	}
   ```

4. 实现call()方法，设置任务随机休眠一段时间，并返回任务名称的信息：

   ```java
   	@Override
   	public String call() throws Exception {
   		try{
   			long duration = (long)(Math.random() * 10);
   			System.out.printf("%s : Waiting %d seconds for results.\n", this.name, duration);
   			TimeUnit.SECONDS.sleep(duration);
   		} catch (InterruptedException e) {}
   		
   		return "Hello, World. I am " + name;
   	}
   ```

5. 实现名为ResultTask的类，继承String类参数化的FutureTask类：

   ```java
   public class ResultTask extends FutureTask<String>{
   ```

6. 定义名为name的私有String属性，存储任务名称：

   ```java
   	private final String name;
   ```

7. 实现类构造函数，需要接收Callable对象作为参数。调用父类的构造函数并使用任务接收到的属性初始化名称属性值：

   ```java
   	public ResultTask(ExecutableTask callable) {
   		super(callable);
   		this.name = callable.getName();
   	}
   ```

8. 重写done()方法，判断isCancelled()方法的值，根据返回值，输出不同的信息到控制台：

   ```java
   	@Override
   	protected void done() {
   		if(isCancelled()) {
   			System.out.printf("%s : Has been canceled\n" , name);
   		} else {
   			System.out.printf("%s : Has finished\n", name);
   		}
   	}
   ```

9. 实现范例的主方法，创建一个包含main()方法的Main类：

   ```java
   public class Main {
   	public static void main(String[] args) {
   ```

10. 使用Executors类的newCachedThreadPool()方法创建ExecutorService：

    ```java
    		ExecutorService executor = Executors.newCachedThreadPool();
    ```

11. 创建数组存储五个ResultTask对象：

    ```java
    		ResultTask resultTasks[] = new ResultTask[5];
    ```

12. 初始化ResultTask对象，对数组中的每个元素，首先使用对象创建ExecutorTask，然后创建ResultTask。接下来使用submit()方法发送ResultTask到执行器：

    ```java
    		for(int i = 0 ; i < 5 ; i ++){
    			ExecutableTask executableTask = new ExecutableTask("Task " +i);
    			resultTasks[i] = new ResultTask(executableTask);
    			executor.submit(resultTasks[i]);
    		}
    ```

13. 设置主线程休眠5秒：

    ```java
    		try {
    			TimeUnit.SECONDS.sleep(5);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    ```

14. 取消发送到执行器的所有任务：

    ```java
    		for (int i=0; i<resultTasks.length; i++) {
    			resultTasks[i].cancel(true);
    		}
    ```

15. 使用ResultTask对象的get()方法，输出未被取消的任务结果到控制台：

    ```java
    		for (int i = 0 ; i < resultTasks.length ; i ++){
    			try {
    				if(!resultTasks[i].isCancelled()) {
    					System.out.printf("%s\n", resultTasks[i].get());
    				}
    			} catch (InterruptedException | ExecutionException e) {
    				// TODO Auto-generated catch block
    				e.printStackTrace();
    			}
    		}
    ```

16. 使用shutdown()方法结束执行器：

    ```java
    		executor.shutdown();
    	}
    }
    ```

### 工作原理

当正在被控制的任务完成其执行时，done()方法被FutureTask类调用。本范例中，实现了Callable对象、ExecutableTask类，以及FutureTask类的子类，用来控制ExecutableTask对象的执行。

done()方法在生成结果值且改变任务状态为isDone之后被FutureTask类内部调用。你无法改变任务结果值或者改变其状态，但是你能够关闭被任务使用的资源，输出日志信息，或者发送通知。FutureTask类可以用来确保特殊的任务只能运行一次，因为调用其run()方法将只执行封装的Runnable/Callable接口一次（并且可用的情况下，使用get能够得到结果）。

### 更多关注

本章“执行器中运行返回结果的任务“小节。

## 执行器中分离任务加载和结果处理

通常情况，当使用执行器运行并发任务时，会发送Runnable或Callable任务到执行器并且获得Future对象来控制方法。会出现需要在一个对象中发送任务到执行器，且在另一个对象中处理结果的局面。Java并发API提供的CompletionService类用来应对这种状况的发生。

CompletionService类提供发送任务到执行器的方法，以及为已经完成执行的下一个任务获得Future对象。此类内部使用Executor对象执行任务，这钟特性的优点是共享CompletionService对象且发送任务到执行器以便其他任务能够处理结果。不足之处则是第二个对象只能为已经完成执行的任务获得Future对象，所以这些Future对象只能用来得到任务结果。

本节中，学习如何使用CompletionService类将执行器中加载任务过程与任务结果的处理分开。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤完成范例：

1. 创建名为ReportGenerator的类，实现String类参数化的Callable接口：

   ```java
   public class ReportGenerator implements Callable<String>{
   ```

2. 定义名为sender和title的两个私有String属性，用来定义报告内容：

   ```java
   	private final String sender;
   	private final String title;
   ```

3. 实现类构造函数，初始化两个属性：

   ```java
   	public ReportGenerator(String sender, String title) {
   		this.sender = sender;
   		this.title = title;
   	}
   ```

4. 实现call()方法。首先，设置线程随机休眠一段时间：

   ```java
   	@Override
   	public String call() throws Exception {
   		try{
   			Long duration = (long)(Math.random() * 10);
   			System.out.printf("%s_%s : ReportGenerator : Generating a report during %d seconds\n", this.sender, this.title, duration);
   			TimeUnit.SECONDS.sleep(duration);
   		} catch(InterruptedException e){
   			e.printStackTrace();
   		}
   ```

5. 然后用sender和title属性内容生成字符串的报告内容，并返回内容：

   ```java
   		String ret = sender + " :  " + title;
   		return ret;
   	}
   ```

6. 创建名为ReportRequest的类，实现Runnable接口，用来模拟一些报告请求：

   ```java
   public class ReportRequest implements Runnable{
   ```

7. 定义名为name的私有String属性，存储ReportRequest的名称：

   ```java
   	private final String name;
   ```

8. 定义名为service的私有CompletionService属性，CompletionService接口是String类参数化的接口：

   ```java
   	private final CompletionService<String> service;
   ```

9. 实现类构造函数，初始化两个属性：

   ```java
   	public ReportRequest(String name, CompletionService<String> service) {
   		this.name = name;
   		this.service = service;
   	}
   ```

10. 实现run()方法，创建三个ReportGenerator对象，使用submit()方法发送到CompletionService对象：

    ```java
    	@Override
    	public void run() {
    		ReportGenerator reportGenerator = new ReportGenerator(name, "Report");
    		service.submit(reportGenerator);
    	}
    ```

11. 创建名为ReportProcessor的类，此类将得到ReportGenerator任务的结果，指定其实现Runnable接口：

    ```java
    public class ReportProcessor implements Runnable{
    ```

12. 定义名为service的私有CompletionService属性，因为CompletionService接口是参数化接口，所以使用String类作为CompletionService接口的参数：

    ```java
    	private final CompletionService<String> service;
    ```

13. 定义名为end的私有Boolean属性，添加volatile 关键字确保所有线程拥有此属性实际值的使用权：

    ```java
    	private volatile boolean end;
    ```

14. 定义类构造函数，初始化这两个属性：

    ```java
    	public ReportProcessor(CompletionService<String> service) {
    		this.service = service;
    		end = false;
    	}
    ```

15. 实现run()方法，当end属性是false时，调用CompletionService接口的poll()方法，获得下一个任务的Future对象，此任务被已经结束的完成服务执行：

    ```java
    	@Override
    	public void run() {
    		while (!end){
    			try {
    				Future<String> result = service.poll(20, TimeUnit.SECONDS);
    ```

16. 然后，使用Future对象的get()方法得到任务结果，并输出结果到控制台：

    ```java
    				if(result != null) {
    					String report = result.get();
    					System.out.printf("ReportReceiver : Report Received : %s\n", report);
    				}
    			} catch (InterruptedException | ExecutionException e) {
    				// TODO Auto-generated catch block
    				e.printStackTrace();
    			}	
    		}
    		System.out.printf("ReportSender : End\n");
    	}
    ```

17. 实现stopProcessing()方法来改变end属性值：

    ```java
    	public void stopProcessing(){
    		this.end = true;
    	}
    ```

18. 实现范例的主方法，创建一个包含main()方法的Main类：

    ```java
    public class Main {
    	public static void main(String[] args) {
    ```

19. 使用Executors类的newCachedThreadPool()方法创建ThreadPoolExecutor：

    ```java
    		ExecutorService executor = Executors.newCachedThreadPool();
    ```

20. 使用执行器创建CompletionService，此执行器作为前面的构造函数的参数被创建：

    ```java
    		CompletionService<String> service = new ExecutorCompletionService<>(executor);
    ```

21. 创建两个ReportRequest对象，以及执行它们的线程：

    ```java
    		ReportRequest faceRequest = new ReportRequest("Face", service);
    		ReportRequest onlineRequest = new ReportRequest("Online", service);
    		
    		Thread faceThread = new Thread(faceRequest);
    		Thread onlineThread = new Thread(onlineRequest);
    ```

22. 创建ReportProcessor对象，以及执行它的线程：

    ```java
    		ReportProcessor processor = new ReportProcessor(service);
    		Thread senderThread = new Thread(processor);
    ```

23. 启动三个线程：

    ```java
    		System.out.printf("Main : Starting the Threads\n");
    		faceThread.start();
    		onlineThread.start();
    		senderThread.start();
    ```

24. 等待ReportRequest线程的结束：

    ```java
    		try {
    			System.out.printf("Main : Waiting for the report generators.\n");
    			faceThread.join();
    			onlineThread.join();
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    ```

25. 使用shutdown()方法结束执行器，然后使用awaitTermination()方法等待任务的结束：

    ```java
    		System.out.printf("Main : Shutting down the executor.\n");
    		executor.shutdown();
    		try {
    			executor.awaitTermination(1, TimeUnit.DAYS);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    ```

26. 结束ReportSender对象的执行，设置end属性值为true：

    ```java
    		processor.stopProcessing();
    		System.out.println("Main : Ends");
    ```

### 工作原理

本范例主类中，使用Executors类的newCachedThreadPool()方法创建ThreadPoolExecutor。然后，用到Executor对象初始化CompletionService对象，因为完成服务使用执行器运行其任务。为了使用完成服务执行任务，用到ReportRequest类中的submit()方法。

当完成服务结束其执行时，其中一个任务被执行，服务存储Future对象用来在队列中控制执行。poll()方法进入队列判断是否有任务已经完成执行，如果有，则返回队列的第一个元素，即任务已经完成执行的Future对象。当poll()方法返回Future对象时，此对象从队列中删除自己。这种情况下，假定队列包含的完成任务的结果为空，则传递两个属性到此方法，指明想要等待任务完成的时间。

一旦CompletionService对象被创建，则创建了两个ReportRequest对象用来执行一个ReportGenerator任务，使用之前创建的CompletionService对象执行另一个ReportGenerator任务，此对象作为参数传递到ReportGenerator对象的构造函数中。

### 扩展学习

CompletionService类能够执行Callable或者Runnable任务，本范例中用到了Callable，但是也可以发送Runnable对象。由于Runnable对象不产生结果，所以CompletionService类设计也没有考虑到此情形。

这个类提供了两个方法获得完成任务的Future对象，如下所示：

- poll()：不带参数的poll()方法判断队列中是否有Future对象。如果队列为空，立即返回空，否则，返回第一个元素并从队列中删除它。
- take()：此方法不带参数，判断队列中是否有Future对象。如果队列为空，则阻塞线程直到队列具有一个元素，如果队列包含元素，此方法返回第一个元素，并且从队列中删除它。

本范例中，超时使用poll()方法来控制结束ReportProcessor任务的执行。

### 更多关注

本章“执行器中运行返回结果的任务“小节。