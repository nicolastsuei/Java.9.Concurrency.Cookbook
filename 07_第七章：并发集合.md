# 并发集合

本章将学习如下内容：

- 使用非阻塞线程安全双端队列
- 使用阻塞线程安全双端队列 
- 使用按优先级排序的阻塞线程安全队列 
- 使用具有延迟元素的线程安全列表
- 使用线程安全的可操纵映射
- 使用线程安全的哈希映射
- 使用原子变量
- 使用原子数组
- 使用易失性关键字
- 使用变量句柄

## 引言

**数据结构**是编程基础要素，绝大多数的程序都用到不止一种数据类型来存储和管理数据。Java API提供了**Java集合框架**，包含接口、类和实现应用到程序中大量不同数据结构的算法。

当在并发程序中处理数据集合时，必须非常谨慎地选择实现方式。大多数集合类并不应用到并发应用中，因为它们无法控制对数据的并发访问。如果并发任务共享一个无法与其它并发任务一起处理的数据结构，则可能会出现数据不一致错误，从而影响程序操作，例如ArrayList类。在并发程序中使用Java提供的数据集合过程，不会出现任何问题和不一致。基本上，Java提供了两种类型的集合在并发应用程序中使用:

- **阻塞集合：**这类集合包含添加和删除数据的操作。因为集合已满或为空，如果操作不能立即执行，那么发出调用的线程将被阻塞，直到操作可以执行。 
- **非阻塞集合：**这类集合也包含添加和删除数据的操作。但如果操作不能立即执行，此集合返回null值或抛出异常，发出调用的线程将不会在这里被阻塞。

通过本章各节，将学习在并发应用中如何使用部分Java集合，包括：

- 非阻塞双端队列，使用ConcurrentLinkedDeque类
- 阻塞双端队列，使用LinkedBlockingDeque类
- 用于数据的生产者和消费者的阻塞队列，使用LinkedTransferQueue类
- 按照优先级排序元素的阻塞队列，使用PriorityBlockingQueue类
- 包含延迟元素的阻塞队列，使用DelayQueue类
- 非阻塞可操纵映射，使用ConcurrentSkipListMap类
- 非阻塞哈希表，使用ConcurrentHashMap类
- 原子变量，使用AtomicLong和AtomicIntegerArray类
- 存储在使用volatile关键字标记的字段中的变量
- 使用变量句柄在各自类字段上进行原子操作。

## 使用非阻塞线程安全双端队列

List被称为最基本的集合，具有不确定数量的元素，可以在任何位置增加、读取，或者删除元素。并发列表允许不同线程在同一时间添加或删除来自列表中的元素，而不会产生任何数据非一致性错误。与列表相似的，还有双端队列，其数据结构与队列相近，但在双端队列中，可以在前（头）后（尾）端添加或删除。

本节将学习在并发应用中如何使用非阻塞双端队列。非阻塞双端队列提供的操作如果没有马上执行完（例如想要得到空列表中的一个元素），将根据操作不同抛出异常或者返回null值。Java 7引入ConcurrentLinkedDeque类实现非阻塞并发双端队列。

将要实现的范例中包含如下两个不同任务：

- 向双端队列添加大量元素
- 从双端队列中删除数据

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为AddTask的类，指定其实现Runnable接口：

   ```java
   public class AddTask implements Runnable{
   ```

2. 声明名为list的String类参数化的私有ConcurrentLinkedDeque属性：

   ```java
   	private final ConcurrentLinkedDeque<String> list;
   ```

3. 实现类构造函数，初始化属性：

   ```java
   	public AddTask(ConcurrentLinkedDeque<String> list) {
   		this.list = list;
   	}
   ```

4. 实现类的run()方法，循环10000次，在每个循环中，获取双端队列的第一个和最后一个元素，所以将得到总计10000个元素：

   ```java
   	@Override
   	public void run() {
   		String name=Thread.currentThread().getName();
   		for (int i=0; i<10000; i++){
   			list.add(name+": Element "+i);
   		}
   	}
   ```

5. 创建名为PollTask的类，指定其实现Runnable接口：

   ```java
   public class PollTask implements Runnable{
   ```

6. 声明名为list的String类参数化的私有ConcurrentLinkedDeque属性：

   ```java
   	private final ConcurrentLinkedDeque<String> list;
   ```

7. 实现类构造函数，初始化属性：

   ```java
   	public PollTask(ConcurrentLinkedDeque<String> list) {
   		this.list = list;
   	}
   ```

8. 实现类的run()方法，通过循环5000次取出双端队列10000个元素，每次取头和尾两个元素：

   ```java
   	@Override
   	public void run() {
   		for (int i=0; i<5000; i++) {
   			list.pollFirst();
   			list.pollLast();
   		}
   	}
   ```

9. 通过创建名为Main的类，添加main()方法，实现本范例主类：

   ```java
   public class Main {
   	public static void main(String[] args) {
   ```

10. 创建名为list的String类参数化的私有ConcurrentLinkedDeque属性：

    ```java
    		ConcurrentLinkedDeque<String> list=new ConcurrentLinkedDeque<>();
    ```

11. 创建名为threads的数组，包含100个Thread对象：

    ```java
    		Thread threads[]=new Thread[100];
    ```

12. 创建100个AddTask对象以及运行这些对象的线程，将线程存储到已创建好的数组中并启动：

    ```java
    		for (int i=0; i<threads.length ; i++){
    			AddTask task=new AddTask(list);
    			threads[i]=new Thread(task);
    			threads[i].start();
    		}
    		System.out.printf("Main: %d AddTask threads have been launched\n",threads.length);
    ```

13. 使用join()方法等待线程执行完成：

    ```java
    		for (int i=0; i<threads.length; i++) {
    			try {
    				threads[i].join();
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    		}
    ```

14. 输出列表长度到控制台：

    ```java
    		System.out.printf("Main: Size of the List: %d\n",list.size());
    ```

15. 创建100个PollTask对象以及运行这些对象的线程，将线程存储到已创建好的数组中并启动：

    ```java
    		for (int i=0; i< threads.length; i++){
    			PollTask task=new PollTask(list);
    			threads[i]=new Thread(task);
    			threads[i].start();
    		}
    		System.out.printf("Main: %d PollTask threads have been launched\n", threads.length);
    ```

16. 使用join()方法等待线程执行完成：

    ```java
    		for (int i=0; i<threads.length; i++) {
    			try {
    				threads[i].join();
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    		}
    ```

17. 输出列表长度到控制台：

    ```java
    		System.out.printf("Main: Size of the List: %d\n",list.size());
    	}
    }
    ```

###工作原理

在本节中，使用String类参数化的ConcurrentLinkedDeque对象来处理数据的非阻塞并发双端队列。下图显示本范例在控制台输出的执行信息：

![pics/07_01.jpg](pics/07_01.jpg)

首先，执行100个AddTask任务来添加元素到列表，每个任务都使用add()方法向列表中插入10000个元素，此方法在双端队列尾部添加新元素。当所有任务完成时，输出双端队列的元素总数到控制台，此时双端队列有1000000个元素。

然后，执行100个PollTGask任务从双端队列中删除元素。每个任务都使用pollFirst()和pollLast()方法从双端队列中删除10000个元素。pollFirst()方法返回和删除双端队列的第一个元素，pollLast()方法返回和删除双端队列的最后一个元素。如果双端队列为空，则返回null值。当所有任务完成时，输出双端队列的元素总数到控制台，此时考虑到ConcurrentLinkedDeque结构不允许列表添加null值，列表具有零个元素。

使用size()方法输出双端队列的元素数量到控制台，需要注意的是此方法返回的值不是准确的，尤其当有线程在列表中添加或删除数据时使用此方法。这个方法必须遍历整个双端队列来计算元素数量，并且此操作能够更改列表的内容。 只有当没有线程修改双端队列时使用此方法，才能保证返回的结果是正确的。

### 扩展学习

ConcurrentLinkedDeque类还有很多从双端队列中获取元素的方法：

- getFirst()和getLast()：这两个方法分别返回双端队列的第一个和最后一个元素，不删除从双端队列中返回的元素。如果双端队列为空，则抛出NoSuchElementExcpetion异常。
- peek()、peekFirst()和peekLast() ：这些方法分别返回双端队列的第一个和最后一个元素，不删除从双端队列中返回的元素。如果双端队列为空，返回null值。
- remove()、removeFirst()和removeLast()：这些方法分别返回双端队列的第一个和最后一个元素，删除从双端队列中返回的元素。如果双端队列为空，则抛出NoSuchElementExcpetion异常。

## 使用阻塞线程安全双端队列

List作为最基本的集合，包含没有限制数量的元素，可以在任何位置增加、读取，或者删除元素。并发列表允许不同线程在同一时间添加或删除来自列表中的元素，而不会产生任何数据非一致性错误。与列表相似的，还有双端队列，其数据结构与队列相近，但在双端队列中，可以在前（头）后（尾）端添加或删除。

本节将学习在并发应用中如何使用阻塞双端队列。阻塞和非阻塞双端队列的主要区别是，阻塞双端队列的插入和删除元素方法，如果因为列表已满或者为空而没有立即执行，则阻塞发起调用的线程，直到可以执行操作。Java提供了LinkedBlockingDeque类来实现阻塞双端队列。

将要实现的范例中包含如下两个不同任务：

- 向双端队列添加大量元素
- 从相同的列表中大规模删除数据

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Client的类，指定其实现Runnable接口：

   ```java
   public class Client implements Runnable {
   ```

2. 声明名为requestList的String类参数化的私有LinkedBlockingDeque属性：

   ```java
   	private final LinkedBlockingDeque<String> requestList;
   ```

3. 实现类构造函数，初始化属性：

   ```java
   	public Client (LinkedBlockingDeque<String> requestList) {
   		this.requestList=requestList;
   	}
   ```

4. 实现run()方法，使用requestList对象的put()方法每隔一秒向双端队列插入五个String对象，循环重复三次：

   ```java
   	@Override
   	public void run() {
   		for (int i=0; i<3; i++) {
   			for (int j=0; j<5; j++) {
   				StringBuilder request=new StringBuilder();
   				request.append(i);
   				request.append(":");
   				request.append(j);
   				try {
   					requestList.put(request.toString());
   				} catch (InterruptedException e) {
   					e.printStackTrace();
   				}
   				System.out.printf("Client added: %s at %s.\n",request, new Date());
   			}
   			try {
   				TimeUnit.SECONDS.sleep(2);
   			} catch (InterruptedException e) {
   				e.printStackTrace();
   			}
   		}
   		System.out.printf("Client: End.\n");
   	}
   }
   ```

5. 通过创建名为Main的类，添加main()方法，实现本范例主类：

   ```java
   public class Main {
   	public static void main(String[] args) throws Exception{
   ```

6. 声明和创建名为list的String类参数化的LinkedBlockingDeque属性，固定队列数量为3：

   ```java
   		LinkedBlockingDeque<String> list=new LinkedBlockingDeque<>(3);
   ```

7. 创建和启动一个Thread对象，执行Client任务：

   ```java
   		Client client=new Client(list);
   		Thread thread=new Thread(client);
   		thread.start();
   ```

8. 使用列表对象的take()方法每隔300毫秒从列表中得到三个String对象，循环重复五次。输出字符串到控制台：

   ```java
   		for (int i=0; i<5 ; i++) {
   			for (int j=0; j<3; j++) {
   				String request=list.take();
   				System.out.printf("Main: Removed: %s at %s. Size: %d\n", request,new Date(), list.size());
   			}
   			TimeUnit.MILLISECONDS.sleep(300);
   		}
   ```

9. 输出信息指明程序执行结束：

   ```java
   		System.out.printf("Main: End of the program.\n");
   	}
   }
   ```

### 工作原理

在本节中，使用String类参数化的LinkedBlockingDeque对象来处理数据的非阻塞并发双端队列。

Client类使用put()方法将字符串插入到双端队列，如果双端队列已满（因为固定了队列大小），此方法将阻塞线程执行，直到列表中有位置为空。

Main类使用take()方法从双端队列中获取字符串。如果队列为空，此方法阻塞线程执行，直到双端队列中存在元素。

如果本范例中用到的LinkedBlockingDeque类的方法在线程阻塞的时候被中断，这些方法都能够抛出InterruptedException异常。所以，添加必要的代码来捕捉这些异常。

### 扩展学习

LinkedBlockingDeque类也提供插入和从双端队列中获取元素的方法，这些方法不是被阻塞，而是抛出异常或者返回null值。如下所示：

- takeFirst()和takeLast()：这两个方法分别返回双端队列的第一个和最后一个元素，删除从双端队列中返回的元素。如果双端队列为空，则阻塞线程直到双端队列中存在元素。
- getFirst()和getLast()：这两个方法分别返回双端队列的第一个和最后一个元素，不删除从双端队列中返回的元素。如果双端队列为空，则抛出NoSuchElementExcpetion异常。
- peek()、peekFirst()和peekLast() ：这些方法分别返回双端队列的第一个和最后一个元素，不删除从双端队列中返回的元素。如果双端队列为空，返回null值。
- poll()、pollFirst()和pollLast()：pollFirst()和pollLast()方法分别返回双端队列的第一个和最后一个元素，删除从双端队列中返回的元素。如果双端队列为空，返回null值。
- add()、addFirst()和addLast()：addFirst()和addLast()分别在双端队列的第一个和最后一个位置添加一个元素。如果队列已满（创建时固定大小），抛出IllegalStateException异常。

### 更多关注

- 本章“使用非阻塞线程安全双端队列”小节

## 使用按优先级排序的阻塞线程安全队列 

当处理数据结构时，通常需要一个有序队列。，Java提供了具有此功能的PriorityBlockingQueue 。

要添加到PriorityBlockingQueue的所有元素都必须实现Comparable接口，或者在队列的构造函数中包含Comparator。 此接口具有一个名为compareTo()的方法来接收相同类型的对象，所以有两个对象进行比较，一个用来执行方法，另一个作为参数接收。如果局部对象比参数对象小的话，就必须返回大于0的数。如果两个对象相等则返回0。

当插入元素时，PriorityBlockingQueue使用compareTo()方法确定元素插入的位置。依据compareTo()方法，大元素将置在队列的头部或尾部。 

**阻塞数据结构**是PriorityBlockingQueue的另一个重要特性。它的方法如果不能立即执行，将阻塞线程直到完成为止。 

本节通过实现范例来学习如何使用PriorityBlockingQueue类，当在相同的列表中存储许多具有不同优先级的事件时，检查队列是否按照指定顺序排列。 

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Event的类，指定其实现Event类参数化的Comparable接口：

   ```java
   public class Event implements Comparable<Event>{
   ```

2. 声明名为thread的私有int属性，存储已经创建事件的线程数：

   ```java
   	private final int thread;
   ```

3. 声明名为priority的使用int属性，存储事件的优先级：

   ```java
   	private final int priority;
   ```

4. 实现类构造函数，初始化属性：

   ```java
   	public Event(int thread, int priority){
   		this.thread=thread;
   		this.priority=priority;
   	}
   ```

5. 实现getThread()方法，返回线程属性值：

   ```java
   	public int getThread() {
   		return thread;
   	}
   ```

6. 实现getPriority()方法，返回优先级属性值：

   ```java
   	public int getPriority() {
   		return priority;
   	}
   ```

7. 实现compareTo()方法，将Event作为参数接收，比较当前事件和作为参数接收的事件。如果当前事件优先级高则返回-1，优先级相等返回0，当前事件优先级低则返回1。记住这与大多数Comparator.compareTo() 实现结果相反：

   ```java
   	@Override
   	public int compareTo(Event e) {
   		if (this.priority>e.getPriority()) {
   				return -1;
   		} else if (this.priority<e.getPriority()) {
   			return 1;
   		} else {
   			return 0;
   		}
   	}	
   }
   ```

8. 创建名为Task的类，指定其实现Runnable接口：

   ```java
   public class Task implements Runnable{
   ```

9. 声明名为id的私有int属性，存储标识任务的数字：

   ```java
   	private final int id;
   ```

10. 声明名为queue的Event类参数化的私有PriorityBlockingQueue属性，存储任务生成的事件：

    ```java
    	private final PriorityBlockingQueue<Event> queue;
    ```

11. 实现类构造函数，初始化其属性：

    ```java
    	public Task(int id, PriorityBlockingQueue<Event> queue) {
    		this.id=id;
    		this.queue=queue;
    	}
    ```

12. 实现run()方法，使用ID在队列中存储1000个事件，标识创建事件的任务，并为每个事件分配1到1000的不同优先级。 使用add()方法存储队列中的事件：

    ```java
    	@Override
    	public void run() {
    		for (int i=0; i<1000; i++){
    			Event event=new Event(id,i);
    			queue.add(event);
    		}
    	}
    }
    ```

13. 通过创建名为Main的类，添加main()方法，实现本范例主类：

    ```java
    public class Main {
    	public static void main(String[] args) {
    ```

14. 创建名为queue的Event类参数化的PriorityBlockingQueue对象：

    ```java
    		PriorityBlockingQueue<Event> queue=new PriorityBlockingQueue<>();
    ```

15. 创建包含五个Thread对象的数组，存储执行五个任务的线程：

    ```java
    		Thread taskThreads[]=new Thread[5];
    ```

16. 创建五个Task对象，存储已创建的数组中的线程：

    ```java
    		for (int i=0; i<taskThreads.length; i++){
    			Task task=new Task(i,queue);
    			taskThreads[i]=new Thread(task);
    		}
    ```

17. 启动已创建的五个线程：

    ```java
    		for (int i=0; i<taskThreads.length ; i++) {
    			taskThreads[i].start();
    		}
    ```

18. 使用join()方法等待五个线程执行完成：

    ```java
    		for (int i=0; i<taskThreads.length ; i++) {
    			try {
    				taskThreads[i].join();
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    		}
    ```

19. 输出队列的实际长度和存储的事件到控制台，使用poll()方法从队列中取出元素：

    ```java
    		System.out.printf("Main: Queue Size: %d\n",queue.size());
    		for (int i=0; i<taskThreads.length*1000; i++){
    			Event event=queue.poll();
    			System.out.printf("Thread %s: Priority %d\n", event.getThread(),event.getPriority());
    		}
    ```

20. 输出包含队列最终长度的信息到控制台：

    ```java
    		System.out.printf("Main: Queue Size: %d\n",queue.size());
    		System.out.printf("Main: End of the program\n");
    	}
    }
    ```

### 工作原理

本范例中，使用PriorityBlockingQueue实现Event对象的优先级队列。如引言所述，在riorityBlockingQueue中存储的所有元素都必须实现Comparable接口，或者为队列的构造函数提供Comparator对象。在这里使用第一个方法，所以在Event类中实现了comPareTo()方法。

所有事件都有一个优先级属性，优先级值较高的元素将是队列中的第一个元素。当实现compareTo()方法时，如果执行此方法的事件比作为参数传递的事件优先级高，则返回-1作为结果。如果执行此方法的事件比作为参数传递的事件优先级低，则返回1作为结果。如果两个对象优先级相同，compareTo()方法返回0。在这里PriorityBlockingQueue类不保证元素顺序。

我们实现了Task任务，添加Event对象到优先级队列。每个任务对象使用add()方法向队列添加1000个优先级从0到999的事件。

Main类的main()方法创建五个Task对象，并在对应的线程中执行这些对象。当所有线程结束执行时，输出所有元素到控制台。使用poll()方法从队列中得到元素，此方法从队列中返回且删除第一个元素。

下图显示本范例在控制台输出的部分执行信息：

![pics/07_02.jpg](pics/07_02.jpg)

可以看到队列如何具有5000个元素的规模，以及第一个元素如何具有最大的优先级值。 

### 扩展学习

PriorityBlockingQueue类还有如下一些方法：

- clear()：此方法删除队列的所有元素。
- take()：此方法返回且删除队列第一个元素，如果队列为空，它阻塞线程，直到队列存在元素。
- put(E e)：这是用于参数化PriorityBlockingQueue类的类，它将作为参数传入的元素插入到队列中。 
- peek()：此方法返回队列第一个元素，但不删除它。

###更多关注

- 本章“使用阻塞线程安全双端队列”小节

##使用具有延迟元素的线程安全列表

Java API提供了一种在DelayQueue类中实现的可以用在并发应用中的数据结构。在此类中，使用激活日期存储元素，返回或从队列中提取元素的方法将忽略这些元素，这些元素数据将在后续出现 ，它们对这些方法不可见。为了获得这种行为，存储在DelayQueue类中的元素需要实现Delayed接口。这个接口可以使用延迟对象，包含getDelay()方法，返回元素激活之前的时间 。此接口强制实现如下两个方法：

- compareTo(Delayed o)：Delayed接口继承Comparable接口。如果执行此方法的对象延迟小于作为参数传递的对象，则返回小于零的值。如果执行此方法的对象延迟大于作为参数传递的对象，则返回大于零的值。如果两个对象延迟相等，返回0。
-  getDelay(TimeUnit unit)：此方法必须返回剩余的时间，直到已过单元参数指定的激活日期。TimeUnit是一个枚举类型的类，包含如下常量：DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS和SECONDS。

在本范例中，通过在DelaydQueue类中存储具有不同激活日期的事件，学习如何使用DelaydQueue类。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Event的类， 指定其实现Delayed接口：

   ```java
   public class Event implements Delayed {
   ```

2. 声明名为startDate的私有Date属性：

   ```java
   	private final Date startDate;
   ```

3. 实现类构造函数，初始化属性：

   ```java
   	public Event (Date startDate) {
   		this.startDate=startDate;
   	}
   ```

4. 实现compareTo()方法，将Delayed对象作为参数接收，返回当前对象与参数之间延迟的差异：

   ```java
   	@Override
   	public int compareTo(Delayed o) {
   		long result=this.getDelay(TimeUnit.NANOSECONDS)-o.getDelay(TimeUnit.NANOSECONDS);
   		if (result<0) {
   			return -1;
   		} else if (result>0) {
   			return 1;
   		}
   		return 0;
   	}
   ```

5. 实现getDelay()方法，返回对象的开始时间与实际时间之间的差异，参数为TimeUnit单位：

   ```java
   	@Override
   	public long getDelay(TimeUnit unit) {
   		Date now=new Date();
   		long diff=startDate.getTime()-now.getTime();
   		return unit.convert(diff,TimeUnit.MILLISECONDS);
   	}
   }
   ```

6. 创建名为Task的类，指定其实现Runnable接口：

   ```java
   public class Task implements Runnable{
   ```

7. 声明名为id的私有int属性，存储标识此任务的数字：

   ```java
   	private final int id;
   ```

8. 声明名为queue的Event类参数化的私有DelayQueue属性：

   ```java
   	private final DelayQueue<Event> queue;
   ```

9. 实现类构造函数，初始化属性：

   ```java
   	public Task(int id, DelayQueue<Event> queue) {
   		this.id=id;
   		this.queue=queue;
   	}
   ```

10. 实现run()方法，首先，计算任务将要创建的事件的激活日期，然后将等于对象ID的秒数添加到实际日期: 

    ```java
    	@Override
    	public void run() {
    		Date now=new Date();
    		Date delay=new Date();
    		delay.setTime(now.getTime()+(id*1000));
    		System.out.printf("Thread %s: %s\n",id,delay);
    ```

11. 使用add()方法在队列中存储100个事件：

    ```java
    		for (int i=0; i<100; i++) {
    			Event event=new Event(delay);
    			queue.add(event);
    		}
    	}
    }
    ```

12. 通过创建名为Main的类，添加main()方法，实现本范例主类：

    ```java
    public class Main {
    	public static void main(String[] args) throws Exception{
    ```

13. 创建Event类参数化的DelayQueue对象：

    ```java
    		DelayQueue<Event> queue=new DelayQueue<>();
    ```

14. 创建包含五个线程对象的数组来存储将要执行的任务：

    ```java
    		Thread threads[]=new Thread[5];
    ```

15. 创建五个不同ID的Task对象：

    ```java
    		for (int i=0; i<threads.length; i++){
    			Task task=new Task(i+1, queue);
    			threads[i]=new Thread(task);
    		}
    ```

16. 启动已创建的五个任务：

    ```java
    		for (int i=0; i<threads.length; i++) {
    			threads[i].start();
    		}
    ```

17. 使用join()方法等到线程执行结束：

    ```java
    		for (int i=0; i<threads.length; i++) {
    			threads[i].join();
    		}
    ```

18. 输出存储在队列中的元素到控制台。当队列长度大于零时，使用poll()方法得到Event类。如果返回null，设置主线程休眠500毫秒等到更多事件激活：

    ```java
    		do {
    			int counter=0;
    			Event event;
    			do {
    				event=queue.poll();
    				if (event!=null) counter++;
    			} while (event!=null);
    				System.out.printf("At %s you have read %d events\n", new Date(), counter);
    				TimeUnit.MILLISECONDS.sleep(500);
    		} while (queue.size()>0);
    	}
    }
    ```

### 工作原理

本节中，我们实现了Event类，此类包含一个唯一属性，事件的激活日期，且实现Delayed接口，可以在DelayQueue类中存储Event对象。

getDelay()方法返回激活日期和实际日期之间的纳秒数。两个日期军事Date类对象，使用getTime()方法返回转换为毫秒的日期。然后，将这个值转换成作为参数接收的TimeUnit。DelayQueue类的工作时间是毫微秒，在这一点上它是透明的。

如果执行compareTo()方法的对象延迟小于作为参数传递的对象，则返回小于零的值。如果延迟大于作为参数传递的对象，则返回大于零的值。如果两个对象延迟相等，返回0。

我们还实现了Task类，包含名为id的integer属性。当执行任务对象时，它将等于任务ID的秒数添加到实际日期，这个日期是此任务在DelayQueue类中存储的事件的激活日期。每个任务对象使用add()方法在队列中存储100个事件。 

最后，在Main类的main()方法中，创建五个Task对象并且在对应的线程中执行。当这些线程完成执行时，使用poll()方法输出所有事件到控制台。此方法检索并删除队列的第一个元素 ，如果队列没有任何活动元素，则返回null值。在调用poll()方法时，如果返回Event类，则增加计数器。当此方法返回null值时，输出计数器值到控制台，且设置线程休眠半秒钟来等待更多的活动时间。当获得500个存储在队列中的事件时，结束程序执行。

下图显示本范例在控制台输出的部分执行信息：

可以看到当程序被激活时，如何只得到100个事件。

> 必须谨慎使用size()方法，此方法返回列表中元素的总数，包括活动和非活动元素。

### 扩展学习

DelayQueue类还有如下一些方法：

- clear()：此方法删除队列的所有元素。
- Offer(E e)：这里E表示用于参数化PriorityBlockingQueue类的类，它将作为参数传入的元素插入到队列中。 
- peek()：此方法检索但不删除队列的第一个元素。
- take()：此方法检索且删除队列第一个元素，如果队列没有活动元素，执行此方法的线程将被阻塞，直到线程得到活动元素。

###更多关注

- 本章“使用阻塞线程安全双端队列”小节

## 使用线程安全的可操纵映射

ConcurrentNavigableMap是声明了Java API提供的数据结构接口，可以在并发程序中使用它。 实现ConcurrentNavigableMap接口的类将元素存储在两个部分中：

- 唯一标识元素的**键**
- 声明元素的其它数据，称为**值**

Java API也提供了实现ConcurrentSkipListMap的类，它是通过ConcurrentNavigableMap接口的行为实现非阻塞列表的接口，在内部使用**跳跃表**来存储数据。跳跃表是基于并行列表的数据结构，能够获得与二叉树类似的运行效率。 查看https://en.wikipedia.org/wiki/Skip_list获取更多关于跳跃表的信息。使用跳跃表可以得到一个排序的数据结构，而不是排序列表，且能更高效的插入、检索或删除元素。 

> 跳跃表由William Pugh在1990年引入。 

当向映射表中插入元素时，使用键来对元素排序，因此所有的元素都被序列化。键需要实现Comparable接口，或者向映射表的构造函数提供Comparator类 。除了返回具体元素的方法，此类还提供了获取映射的子映射方法。

本节将学习如何使用ConcurrentSkipListMap类实现联系人映射表。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Contact的类：

   ```java
   public class Contact {
   ```

2. 声明两个名为name和phone的私有属性：

   ```java
   	private final String name;
   	private final String phone;
   ```

3. 实现类构造函数，初始化属性：

   ```java
   	public Contact(String name, String phone) {
   		this.name=name;
   		this.phone=phone;
   	}
   ```

4. 实现返回name和phone属性值的方法：

   ```java
   	public String getName() {
   		return name;
   	}
   	public String getPhone() {
   		return phone;
   	}
   }
   ```

5. 创建名为Task的类，指定其实现Runnable接口：

   ```java
   public class Task implements Runnable{
   ```

6. 声明名为map的String和Contact类参数化的私有ConcurrentSkipListMap属性：

   ```java
   	private final ConcurrentSkipListMap<String, Contact> map;
   ```

7. 声明名为id的私有String属性，存储当前任务ID：

   ```java
   	private final String id;
   ```

8. 实现类构造函数，初始化属性：

   ```java
   	public Task (ConcurrentSkipListMap<String, Contact> map,String id){
   		this.id=id;
   		this.map=map;
   	}
   ```

9. 实现run()方法，使用任务ID和创建Contact对象的增量数在映射中存储1000个联系人。 使用put()方法存储映射表中的联系人：

   ```java
   	@Override
   	public void run() {
   		for (int i=0; i<1000; i++) {
   			Contact contact=new Contact(id, String.valueOf(i+1000));
   			map.put(id+contact.getPhone(), contact);
   		}
   	}
   }
   ```

10. 通过创建名为Main的类，添加main()方法，实现本范例主类：

    ```java
    public class Main {
    	public static void main(String[] args) {
    ```

11. 创建名为map的String和Contact类参数化的私有ConcurrentSkipListMap属性：

    ```java
    		ConcurrentSkipListMap<String, Contact> map = new ConcurrentSkipListMap<>();
    ```

12. 创建包含26个Thread对象的数组，存储所有将要执行的Task对象：

    ```java
    		Thread threads[]=new Thread[26];
    		int counter=0;
    ```

13. 创建并启动26个任务对象，并为每个任务ID分配一个大写字母：

    ```java
    		for (char i='A'; i<='Z'; i++) {
    			Task task=new Task(map, String.valueOf(i));
    			threads[counter]=new Thread(task);
    			threads[counter].start();
    			counter++;
    		}
    ```

14. 使用join()方法等待线程结束：

    ```java
    		for (Thread thread : threads){
    			try {
    					thread.join();
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    		}
    ```

15. 使用firstEntry()方法得到映射表首个条目，输出数据到控制台：

    ```java
    		System.out.printf("Main: Size of the map: %d\n",map.size());
    		Map.Entry<String, Contact> element;
    		Contact contact;
    		element=map.firstEntry();
    		contact=element.getValue();
    		System.out.printf("Main: First Entry: %s: %s\n", contact.getName(), contact.getPhone());
    ```

16. 使用lastEntry()方法得到映射表最后一个条目，输出数据到控制台：

    ```java
    		element=map.lastEntry();
    		contact=element.getValue();
    		System.out.printf("Main: Last Entry: %s: %s\n", contact.getName(), contact.getPhone());
    ```

17. 使用subMap()方法获得映射表的子映射，输出数据到控制台：

    ```java
    		System.out.printf("Main: Submap from A1996 to B1002: \n");
    		ConcurrentNavigableMap<String, Contact> submap=map.subMap("A1996","B1002");
    		do {
    			element=submap.pollFirstEntry();
    			if (element!=null) {
    					contact=element.getValue();
    					System.out.printf("%s: %s\n", contact.getName(), contact.getPhone());
    			}
    		} while (element!=null);
    	}
    }
    ```

### 工作原理

本节在可控制映射中实现Task类来存储Contact对象。每个联系人都有一个名称，这是创建其任务的ID，以及一个电话号码，这个号码在1000到2000之间。将这些值连接为联系人的键，每个Task对象创建1000个联系人，使用put()方法将这些联系人存储到可控制映射中。 

> 如果插入一个映射中已存在键的元素，那么与此键关联的元素将被新元素取代。 

Main()类的main()方法使用大写字母A到Z作为ID创建26个Task对象，然后用一些方法从映射表中获取数据。firstEntry()方法返回包含映射表首个元素的Map.Entry对象，此方法不删除映射表元素。对象包括键和元素，调用getValue()方法获得此元素，可以使用getKey()方法得到元素的键值。

lastEntry()方法返回包含映射表最后一个元素的Map.Entry对象，此时元素的键在A1996到B1002之间。使用pollFirst()方法处理subMap()方法的元素。此方法返回且删除子映射的首个Map.Entry对象。

下图显示本范例在控制台输出的执行信息：

![pics/07_03.jpg](pics/07_03.jpg)

### 扩展学习

ConcurrentSkipListMap类还有如下一些方法：

- headMap(K toKey)：这里K是在ConcurrentSkipListMap对象的参数化中使用的键值的类。此方法返回映射表首个元素的子映射，其中元素比作为参数传递的元素键值小。 
- tailMap(K fromKey)：这里K是在ConcurrentSkipListMap对象的参数化中使用的键值的类。此方法返回映射表最后一个元素的子映射，其中元素比作为参数传递的元素键值大。 
- putIfAbsent(K key, V Value)：此方法插入作为参数指定的值，如果映射中不存在则将其作为参数指定的键。
- pollLastEntry()：此方法返回且删除包含映射表最后一个元素的Map.Entry对象。
- replace(K key, V Value)：如果映射表中存在此键，此方法则替换与指定为参数的键相关联的值。

###更多关注

- 本章“使用非阻塞线程安全双端队列”小节

##使用线程安全的哈希映射

哈希表是将键映射到值的数据结构，通常在内部使用数组存储元素和使用键计算元素在数组中位置的哈希函数。这种数据结构的主要优点是插入、删除和检索操作速度非常快，所以在执行大量检索时非常有用。

Java API通过Map和ConcurrentMap接口提供了不同的哈希表实现。ConcurrentMap接口为所有操作提供线程安全和原子保证，因此可以在并发应用中使用。 ConcurrentHashMap类实现ConcurrentMap接口，并向接口中声明的方法添加了更多的方法。此类支持如下特性：

- 读操作的完全并发性
- 插入和删除操作的高预期并发性 

Java 版本5中引入这两类元素（类和接口），但在版本8中，提供了许多与流API提供的方法类似的新方法。

本节学习在应用中如何使用ConcurrentHashMap类及其提供的重要方法。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Operation的类，包括三个属性：名为user的String属性，名为operation的String属性，和名为time的Date属性。添加这些属性的读取值方法。代码很简单，不在这里列出。

2. 创建名为HashFiller的类，指定其实现Runnable接口：

   ```java
   public class HashFiller implements Runnable{
   ```

3. 声明名为userHash的私有ConsurrentHashMap属性，哈希的键是String类型，值是Operation对象的ConcurrentLinkedDeque对象。实现类构造函数，初始化属性：

   ```java
   	private ConcurrentHashMap<String, ConcurrentLinkedDeque<Operation>> userHash;
   	public HashFiller(ConcurrentHashMap<String, ConcurrentLinkedDeque <Operation>> userHash) {
   		this.userHash = userHash;
   	}
   ```

4. 实现run()方法，将100个随机Operation对象填充到ConsurrentHashMap。首先，生成随机数据，然后在哈希中使用addOperationToHash()方法插入对象：

   ```java
   	@Override
   	public void run() {
   		Random randomGenerator = new Random();
   		for (int i = 0; i < 100; i++) {
   			Operation operation = new Operation();
   			String user = "USER" + randomGenerator.nextInt(100);
   			operation.setUser(user);
   			String action = "OP" + randomGenerator.nextInt(10);
   			operation.setOperation(action);
   			operation.setTime(new Date());
   			addOperationToHash(userHash, operation);
   		}
   	}
   ```

5. 实现addOperationToHash()方法，接收作为参数添加的散列和操作，映射中的键将是分配操作的用户。使用computeIfAbsent()方法来获取与键相关联的ConcurrentLinkedDeque对象。如果键存在，此方法返回与键相关联的值。如果不存在，则执行作为参数传递给此方法的lambda表达式，以生成值并与键关联。 在这里，我们生成新的ConcurrentLinkedDeque对象。最后，将此操作插入到双端队列中：

   ```java
   	private void addOperationToHash(ConcurrentHashMap<String, ConcurrentLinkedDeque<Operation>> userHash2, Operation operation) {
   		ConcurrentLinkedDeque<Operation> opList = userHash.computeIfAbsent(operation.getUser(), user -> new ConcurrentLinkedDeque<>());
   		opList.add(operation);
   	}
   }
   ```

6. 现在实现包含main()方法的Main类。首先，声明ConcurrentHashMap对象和HashFiller任务：

   ```java
   		ConcurrentHashMap<String, ConcurrentLinkedDeque<Operation>> userHash = new ConcurrentHashMap<>();
   		HashFiller hashFiller = new HashFiller(userHash);
   ```

7. 使用HashFiller类执行10个线程，然后使用join()方法等待线程结束：

   ```java
   		Thread[] threads = new Thread[10];
   		for (int i = 0; i < 10; i++) {
   			threads[i] = new Thread(hashFiller);
   			threads[i].start();
   		}
   		for (int i = 0; i < 10; i++) {
   			try {
   				threads[i].join();
   			} catch (InterruptedException e) {
   				e.printStackTrace();
   			}
   		}
   ```

8. 现在，提取ConcurrentHashMap信息。首先，使用size()方法提取存储在映射表中的元素数量。然后，使用forEach()方法对存储在哈希表中的所有元素引入一个操作。第一个参数是并行阈值，是能够以并发方式执行操作所需的最小元素数量。我们指定此参数值为10，并且哈希表有100个元素，所以能够并行执行操作。lambda表达式接收两个参数：键和值。输出键和ConcurrentLinkedDeque存储的长度作为值到控制台：

   ```java
   		System.out.printf("Size: %d\n", userHash.size());
   		userHash.forEach(10, (user, list) -> {
   			System.out.printf("%s: %s: %d\n", Thread.currentThread().getName(), user, list.size());
   		});
   ```

9. 然后使用forEachEntry()方法，与forEach()相似，但lambda表达式接收Entry对象作为参数。可以使用这个entry对象来获得键和值：

   ```java
   		userHash.forEachEntry(10, entry -> { 
   			System.out.printf("%s: %s: %d\n", Thread.currentThread().getName(), entry.getKey(), entry.getValue().size());
   		});
   ```

10. 然后，使用search()方法查找满足指定检索函数的第一个元素。 本范例中，检索操作代码以1结尾的操作。对于forEach()方法，我们指定了并行阈值： 

    ````java
    		Operation op = userHash.search(10, (user, list) -> {
    			for (Operation operation : list) {
    				if (operation.getOperation().endsWith("1")) {
    					return operation;
    				}
    			}
    			return null;
    		});
    		System.out.printf("The operation we have found is: %s, %s, %s,\n", op.getUser(), op.getOperation(), op.getTime());
    ````

11. 再次使用search()方法，但这次用来查找有10个以上操作的用户：

    ```java
    		ConcurrentLinkedDeque<Operation> operations = userHash.search(10, (user, list) -> {
    			if (list.size() > 10) {
    				return list;
    			}
    			return null;
    		});
    		System.out.printf("The user we have found is: %s: %d operations\n", operations.getFirst().getUser(), operations.size());
    ```

12. 最后，使用reduce()方法计算存储在哈希表中的操作总数：

    ```java
    		int totalSize = userHash.reduce(10, (user, list) -> { return list.size(); }, (n1, n2) -> { return n1 + n2; });
    		System.out.printf("The total size is: %d\n", totalSize);
    ```

### 工作原理

本节中，实现了使用ConcurrentHashMap来存储用户操作的信息的范例。哈希表在内部使用Operation类的user属性作为键，以及ConcurrentLinkedDeque(非阻塞并发列表)作为值来存储与此用户关联的所有操作。

首先，使用10个不同的线程填充一些随机数到哈希表中，为此实现了HashFillter任务。这些任务最大的问题是在哈希表中需要插入键时出现的情况。如果两个线程在同一时刻添加相同的键时，其中一个线程插入的数据将会丢失并具有数据竞争条件。为了解决这个问题，我们用到computeIfAbsent()方法。

此方法接收键和表示为lambda表达式的函数接口实现，将键和接口实现作为参数接收。如果键存在，此方法返回与键相关联的值。如果不存在，此方法执行指定的Function对象，并将函数返回的键和值添加HashMap中。本范例中，键是不存在的，所以我们创建了ConcurrentLinkedDeque类的新实例。此方法的主要优点是能够自动执行，也就是说，如果其它线程尝试执行相同操作，它将被阻塞，直到此操作完成。

然后，在main()方法中，用到ConcurrentHashMap的其它方法来处理存储在哈希表中的信息，方法如下：

- forEach()：此方法将BiConsumer接口实现作为参数接收，此接口可以表示为lambda表达式。 lambda表达式的其它两个参数分别代表键和正在处理的元素值。此方法将表达式应用于存储在ConcurrentHashMap中的所有元素。
- forEachEntry()：此方法与上一个方法相同，但是这里的表达式是Consumer接口实现。它将Entry对象作为参数接收，此对象存储键和正在处理的条目值。这也是表达相同功能的另一种方式。
- search()：此方法将BiFunction接口实现作为参数接收，此接口可以表示为lambda表达式。此函数还接收作为参数处理的ConcurrentHashMap对象条目的键和值，返回BiFunction返回的第一个非空值。
- reduce()：此方法接收两个BiFunction接口，将ConcurrentHashMap的元素减少到一个唯一值，可以使用ConcurrentHashMap的元素实现MapReduce操作。第一个BiFunction接口将元素的键和值转换成唯一值，第二个BiFunction接口聚合两个不同元素的值。 

到目前为止所描述的所有方法都有一个名为parallelismThreshold的第一个参数 。此参数被描述为"...并行执行此操作所需的(预估的)元素数量... "，也就是说，如果ConcurrentHashMap的元素比参数中指定的值少，那么此方法将按顺序执行。反之（如本范例），此方法则并行执行。

### 扩展学习

ConcurrentHashMap具有比前一节中讲解的更多的方法，如下所示部分方法：

forEachKey()和forEachValue()：这两个方法与forEach()方法相似，但这里，表达式分别处理在ConcurrentHashMap中存储的键和值。

searchEntries()、searchKeys()和searchValues()：这些方法与之前介绍的search()方法相似。不过在这里，作为参数传递的表达式接收Entry对象、键或存储在ConcurrentHashMap中的元素的值。 

reduceEntries()、reduceKeys()和reduceValues()：这些方法与之前介绍的reduce()方法相似。不过在这里，作为参数传递的表达式接收Entry对象、键或存储在ConcurrentHashMap中的元素的值。 

reduceXXXToDouble()、reduceXXXToLong()和reduceXXXToInt()：这些方法分别通过生成double、long或int值来减少ConcurrentHashMap的元素。 

computeIfPresent()：此方法补充computeIfAbsent()方法，接收能够表示为lambda表达式的BiFunction接口的键和实现。如果键在HashMap存在，此方法应用表达式计算键的新值。BiFunction接口将键和此键的实际值作为参数接收，并返回新值。 

merge()：此方法接收键、值和能够表示为lambda表达式的BiFunction接口实现，它们作为参数被接收。如果键在ConcurrentHashMap中不存在，则此键插入且将参数值与之关联。如果存在，执行BiFunction计算关联键的新值。BiFunction接口将键及其实际值作为参数接收，返回与键相关联的新值。

getOrDefault()：此方法将键和默认值作为参数接收。如果键在ConcurrentHashMap存在，则返回相关联的值。否则，返回默认值。

### 更多关注

- 本章“使用线程安全的可操纵映射”小节
- 第六章“并行和反应流”中的“归约流元素”小节

## 使用原子变量

**原子变量**在Java版本5中引入，用于对单个变量进行原子操作。当使用普通变量时，Java实现的每个操作均被转换为Java字节代码指令，当编译程序时JVM能够理解这些指令。例如，当给变量分配值时，Java中只使用一个指令，但是当编译程序时，JVM语言汇总会转换成不同的指令。当使用共享变量的多个线程时，会导致数据不一致错误。

为避免这些问题，Java引入原子变量。当线程正在对原子变量执行操作时，如果其他线程希望对同一个变量执行操作，则类实现包含检查操作是否以原子方式完成的机制。基本上，此操作获取变量值，将值更改为局部变量，然后尝试用新值更改旧值。如果旧值不变，则被替代，如果没有，此方法将重新开始操作。这个操作称之为**比较和设置**，实现以下三个步骤修改变量的值：

1. 得到变量的值，即变量的旧值。
2. 在临时变量中更改变量值，即变量的新值。
3. 如果旧值等于变量的实际值，则用新值替换旧值。如果另一个线程更改变量的值，则旧值可能与实际值不同。

一些变量，例如LongAccumulator类，将能够在此类的一些方法中执行的操作作为参数接收。这些操作必须没有任何副作用，因为它们可能在每次值更新中被多次执行。

 原子变量不使用锁或其它同步机制来保护对其值的访问。它们的所有操作都基于比较和设置，保证多个线程能够同时处理一个原子变量，而不会产生数据不一致的错误，此外也简化了实现 。

Java 8中新增了四个新的原子类，首先是LongAdder和DoubleAdder类，存储由不同线程频繁更新的长整型和双精度值。使用AtomicLong类能够得到与LongAdder类相同的功能，但是前者提供了更好的性能。另外两个类是LongAccumulator和DoubleAccumulator。这些类与前面的类相似，但这里需要在构造函数中指定两个参数：

- 计数器的初始值。
- 能够表示为lambda表达式的LongBinaryOperator或DoubleBinaryOperator。此表达式接收变量的旧值和要应用的增量，并返回变量的新值。

本节将学习如何使用原子变量实现银行账户和两个不同的任务：一个任务把钱存入账户，另一个是从账户中取出钱。本范例实现将使用AtomicLong类。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Account的类模拟银行账户：

   ```java
   public class Account {
   ```

2. 声明名为balance的私有AtomicLong属性，存储账户余额。此外声明名为operation的私有LongAdder属性和名为commission的私有DoubleAccumulator属性：

   ```java
   	private final AtomicLong balance;
   	private final LongAdder operations;
   	private final DoubleAccumulator commission;
   ```

3. 实现类构造函数初始化这些属性。对于DoubleAccumulator类，其标识值为0，我们将用0.2为参数的增量结果来更新实际值：

   ```java
   	public Account() {
   		balance = new AtomicLong();
   		operations = new LongAdder();
   		commission = new DoubleAccumulator((x,y)-> x+y*0.2, 0);
   	}
   ```

4. 实现获得这三个属性值的方法：

   ```java
   	public long getBalance() {
   		return balance.get();
   	}
   	
   	public long getOperations() {
   		return operations.longValue();
   	}
   	
   	public double getCommission() {
   		return commission.get();
   	}
   ```

5. 实现名为setBalance()的方法来设置balance属性值。还要用reset()方法初始化operation和commission属性：

   ```java
   	public void setBalance(long balance) {
   		this.balance.set(balance);
   		operations.reset();
   		commission.reset();
   	}
   ```

6. 实现名为addAmount()的方法来增加balance属性值，使用LongAdder类的increment()方法增加operations属性值，以及accumulate()方法按20%的增量金额值作用在commision对象上：

   ```java
   	public void addAmount(long amount) {
   		this.balance.getAndAdd(amount);
   		this.operations.increment();
   		this.commission.accumulate(amount);
   	}
   ```

7. 实现名为substractAmount()的方法减少balance属性值。由于伴随着addAmount()方法，我们修改operations和commission值：

   ```java
   	public void subtractAmount(long amount) {
   		this.balance.getAndAdd(-amount);
   		this.operations.increment();
   		this.commission.accumulate(amount);
   	}
   }
   ```

8. 创建名为Company的类，指定其实现Runnable接口。此类模拟公司支付的款项：

   ```java
   public class Company implements Runnable{
   ```

9. 声明名为account的私有Account属性：

   ```java
   	private final Account account;
   ```

10. 实现类构造函数，初始化属性：

   ```java
   	public Company(Account account) {
   		this.account=account;
   	}
   ```

11. 实现任务的run()方法，使用账户的addAmount()方法将数量为1000的钱分10次添加到余额里：

    ```java
    	@Override
    	public void run() {
    		for (int i=0; i<10; i++){
    			account.addAmount(1000);
    		}
    	}
    }
    ```

12. 创建名为Bank的类，指定其实现Runnable接口。此类模拟从账户中提取钱：

    ```java
    public class Bank implements Runnable{
    ```

13. 声明名为account的私有Account属性：

    ```java
    	private final Account account;
    ```

14. 实现类构造函数，初始化属性：

    ```java
    	public Bank(Account account) {
    		this.account=account;
    	}
    ```

15. 实现任务的run()方法，使用账户的subtractAmount()方法将数量为1000的钱分10次从余额里取出：

    ```java
    	@Override
    	public void run() {
    		for (int i=0; i<10; i++){
    			account.subtractAmount(1000);
    		}
    	}
    }
    ```

16. 创建名为Main的类实现本范例的主类，添加main()方法：

    ```java
    public class Main {
    	public static void main(String[] args) {
    ```

17. 创建Account对象，设置余额为1000：

    ```java
    		Account account=new Account();
    		account.setBalance(1000);
    ```

18. 创建新的Company任务和执行此任务的线程：

    ```java
    		Company company=new Company(account);
    		Thread companyThread=new Thread(company);
    ```

19. 创建新的Bank任务和执行此任务的线程：

    ```java
    		Bank bank=new Bank(account);
    		Thread bankThread=new Thread(bank);
    ```

20. 输出账户的初始余额到控制台：

    ```java
    		System.out.printf("Account : Initial Balance: %d\n", account.getBalance());
    ```

21. 启动线程：

    ```java
    		companyThread.start();
    		bankThread.start();
    ```

22. 使用join()方法等待线程执行结束，输出最终余额、操作次数和累计的账户佣金到控制台：

    ```java
    		try {
    			companyThread.join();
    			bankThread.join();
    			System.out.printf("Account : Final Balance: %d\n", account.getBalance());
    			System.out.printf("Account : Number of Operations: %d\n", account.getOperations());
    			System.out.printf("Account : Accumulated commisions: %f\n", account.getCommission());
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    	}
    }
    ```

### 工作原理

本范例的关键在Account类中，我们声明了名为balance的AtomicLong变量，用来存储账户余额；名为operations的LongAdder变量来存储在账户上进行的操作次数；以及名为commission的DoubleAccumulator变量来存储交易佣金值。在commission对象构造函数中，指定佣金值增量为0.2*y。因此，我们指定变量的实际值是传递到accumulate()方法中的参数值乘以0.2。

为了实现返回balance属性值的getBalance()方法，用到了AtomicLong类的get()方法。为了实现返回操作次数的long值得getOperations()方法，用到了longValue()方法。为了实现getCommission()方法，用到了DoubleAccumulator类的setBalance()方法。为了实现设置balance属性值的setBalance()方法，用到了AtomicLong类的set()方法。

为了实现addAmount()方法用来增加账户余额的输入，用到了AtomicLong类的getAndAdd()方法，此方法返回值并按指定为参数的值递增。我们还使用LongAdder类的increment()方法将变量的值加1，以及DoubleAccumulator类的collect()方法将commission属性的值按照指定的表达式递增。需要注意的是addAmount()方法总的来说不是原子的，尽管它调用了三个原子操作。

最后，为了实现subtractAmount()方法用来递减balance属性值，用到了getAndAdd()方法，还包括调用的LongAdder和DoubleAccumulator类的increment()和accumulate()对象。

然后，实现两个不同的任务：

- Company类模拟公司增加账户余额。此类的每次任务执行存入1000的金额10次。
- Bank类模拟银行从账户中取出钱。此类的每次任务执行取出1000的金额10次。

在Main类中，创建初始余额为1000的Account对象。然后，执行一次银行操作和一次公司操作，这样账户最终余额与初余额相同。

当执行范例时，将会看到最终余额是如何与初始余额相同的。下图显示本范例在控制台输出的执行信息：

![pics/07_04.jpg](pics/07_04.jpg)

### 扩展学习

如引言所述，Java中还有其它的原子类。例如AtomicBoolean、AtomicInteger和AtomicReference。

LongAdder还提供如下一些方法：

- add()：通过指定为参数的值来增加内部计数器的值
- decrement()：内部计数器减1
- reset()：返回内部值为0

也可以使用与LongAdder相似的DoubleAdder类，但是此类没有increment()和decrement()方法，并且内部计数器是double值。

还可以使用与DoubleAccumulator相似的LongAccumulator类，但是内部计数器是long型。

### 更多关注

第二章“基础线程同步”中的“同步方法”小节	

## 使用原子数组

考虑到需要实现一个并发应用程序，具有一个或多个由多个线程共享的对象。在这种情况下，需要使用同步机制（如锁或synchronized关键字）保护对其属性的访问，以避免数据不一致错误。 

这些机制有如下问题：

- 死锁：这种情况发生在一个线程被阻塞，等待被其它线程一直锁定的锁，导致阻塞程序，因此永远不会运行结束。
- 如果只有一个线程访问共享对象，则需要执行获取和释放锁所需的代码。

为了在这种情况下提供更好的性能，开发了**比较和交换操作**。此操作通过以下三个步骤实现修改变量值：

1. 得到变量值，即变量的旧值。
2. 在临时变量中修改变量值，即变量的新值。
3. 如果旧值与变量的实际值相等，则用新值替换旧值。如果其它线程更改了旧值，旧值可能与实际值不同。

使用这种机制，就不需要使用同步机制，因此可以避免死锁，从而获得更好的性能。 这种机制也有缺点，首先操作必须没有任何副作用，因为它们可能会被重新尝试使用充满竞争资源的活锁；其次与标准锁相比，它们也更难监视性能。 

Java在**原子变量**中实现此机制，这些变量提供了compareAndSet()方法，实现了比较与交换操作和其它基于此操作的方法。

Java还引入原子数组，提供整型和长整型数组的原子操作。本节将学习如何使用AtomicIntegerArray类来处理原子数组。注意如果使用AtomicInteger[]，它不是线程安全的对象。单个AtomicInteger对象是线程安全的，但是作为数据结构的数组不是。

###准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Incrementer的类，实现Runnable接口：

   ```java
   public class Incrementer implements Runnable{
   ```

2. 声明名为vector的私有AtomicIntegerArray属性，存储整型数组：

   ```java
   	private final AtomicIntegerArray vector;
   ```

3. 实现类构造函数，初始化其属性：

   ```java
   	public Incrementer(AtomicIntegerArray vector) {
   		this.vector=vector;
   	}
   ```

4. 实现run()方法，使用getAndIncrement()方法增加数组的所有元素：

   ```java
   	@Override
   	public void run() {
   		for (int i=0; i<vector.length(); i++){
   			vector.getAndIncrement(i);
   		}
   	}
   }
   ```

5. 创建名为Decrementer的类，实现Runnable接口：

   ```java
   public class Decrementer implements Runnable {
   ```

6. 声明名为vector的私有AtomicIntegerArray属性，存储整型数组：

   ```java
   	private AtomicIntegerArray vector;
   ```

7. 实现类构造函数，初始化其属性：

   ```java
   	public Decrementer(AtomicIntegerArray vector) {
   		this.vector=vector;
   	}
   ```

8. 实现run()方法，使用getAndDecrement()方法递减数组的所有元素：

   ```java
   	@Override
   	public void run() {
   		for (int i=0; i<vector.length(); i++) {
   			vector.getAndDecrement(i);
   		}
   	}
   }
   ```

9. 通过创建名为Main的类，在类中添加main()方法实现本范例的主类：

   ```java
   public class Main {
   	public static void main(String[] args) {
   ```

10. 声明名为THREADS的常量，赋值100。创建包含1000个元素的AtomicIntegerArray对象：

    ```java
    		final int THREADS=100;
    		AtomicIntegerArray vector=new AtomicIntegerArray(1000);
    ```

11. 创建Incrementer任务处理之前创建的原子数组：

    ```java
    		Incrementer incrementer=new Incrementer(vector);
    ```

12. 创建Decrementer任务处理之前创建的原子数组：

    ```java
    		Decrementer decrementer=new Decrementer(vector);
    ```

13. 创建两个数组存储100个Thread对象：

    ```java
    		Thread threadIncrementer[]=new Thread[THREADS];
    		Thread threadDecrementer[]=new Thread[THREADS];
    ```

14. 创建和加载100个线程执行Incrementer任务，100个线程执行Decrementer任务，分别存储到之前创建的数组中：

    ```java
    		for (int i=0; i<THREADS; i++) {
    			threadIncrementer[i]=new Thread(incrementer);
    			threadDecrementer[i]=new Thread(decrementer);
    			threadIncrementer[i].start();
    			threadDecrementer[i].start();
    		}
    ```

15. 使用join()方法等待线程结束：

    ```java
    		for (int i=0; i<100; i++) {
    			try {
    				threadIncrementer[i].join();
    				threadDecrementer[i].join();
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    		}
    ```

16. 在控制台中输出与0不同的原子数组元素，使用get()方法得到原子数组的元素：

    ```java
    		int errors=0;
    		for (int i=0; i<vector.length(); i++) {
    			if (vector.get(i)!=0) {
    				System.out.println("Vector["+i+"] : "+vector.get(i));
    				errors++;
    			}
    		}
    		if (errors==0) {
    			System.out.printf("No errors found\n");
    		}
    ```

17. 输出表示本范例结束的信息到控制台：

    ```java
    		System.out.println("Main: End of the example");
    	}
    }
    ```

### 工作原理

本范例中实现两个不同的任务来处理一个AtomicIntegerArray对象：

- Incrementer：此类使用getAndIncrement()方法递增数组所有元素
- Decrementer：此类使用getAndDecrement()方法递减数组所有元素

在Main类中，创建包含1000个元素的AtomicIntegerArray，然后执行100个incrementer和100个decrementer任务。在这些任务结尾，如果没有非连续性错误，数组的所有元素值必须为0。如果执行程序，将看到程序如何只将最终消息输出到控制台，因为所有元素都为零。

### 扩展学习

现在Java提供了另一种原子数组类，名为AtomicLongArray类，提供了与IntegerAtomicArray类相同的方法。

这些类还提供如下方法：

- get(int i)：返回数组中参数指定位置的值
- set(int I, int newValue)：建立参数指定的数组位置的值

### 更多关注

- 本章“使用原子变量”小节

##使用易失性关键字

几乎所有应用程序都将数据读写到计算机的主存中，考虑到性能因素，这些操作不会直接在内存中执行。CPU提供缓存内存系统，应用程序在缓存中写入数据，然后将数据从缓存移到主内存。 

在多线程应用中，并发线程在不同的CPU或CPU中不同的内核中运行。当线程修改存储在内存中的变量时，是在缓存或正在运行的CPU或内核中进行修改，但无法保证修改会在何时到达主内存。如果其它线程想要读取数据值，因为此数据不在计算机主存中，所以可能不会读取修改后的值。  

为了解决这个问题（还有其它解决方案，例如synchronized关键字），Java语言提供volatile关键字。此关键字为修饰符，指定变量必须始终从主内存而不是CPU的缓存中读取并存储。当其它线程对变量的实际值具有可见性更重要时，应该使用volatile关键字，但访问此变量的顺序并不重要。在此场景中，volatile关键字提供更好的性能，因为它不需要任何监视器或锁来访问变量。与之相反，如果变量的访问顺序很重要，则必须使用另一种同步机制。

本节将学习如何使用易失性关键字及使用效果。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Flag的类，包含名为flag的公有Boolean属性，初始值为true：

   ```java
   public class Flag {
   	public boolean flag = true;
   }
   ```

2. 创建名为VolatileFlag的类，包含名为flag的公有Boolean属性，初始值为true。在属性声明上添加volatile修饰符：

   ```java
   public class VolatileFlag {
   	public volatile boolean flag = true;
   }
   ```

3. 创建名为Task的类，指定其实现Runnable接口。包含私有Flag属性以及初始化此属性的构造函数：

   ```java
   public class Task implements Runnable{
   	private  Flag flag;
   	public Task(Flag flag) {
   		this.flag = flag;
   	}
   ```

4. 实现此任务的run()方法。当flag属性值为true时，int变量加1。然后输出变量的最终结果到控制台：

   ```java
   	@Override
   	public void run() {
   		int i = 0 ;
   		while (flag.flag) {
   			i++;
   		}
   		System.out.printf("Task: Stopped %d - %s\n", i, new Date());
   	}
   }
   ```

5. 创建名为VolatileTask的类，指定其实现Runnable接口。包含私有VolatileFlag属性以及初始化此属性的构造函数：

   ```java
   public class VolatileTask implements Runnable{
   	private VolatileFlag flag;
   	public VolatileTask(VolatileFlag flag) {
   		this.flag = flag;
   	}
   ```

6. 实现此任务的run()方法，代码与Task类相同，不在这里列出：

   ```java
   	@Override
   	public void run() {
   		int i = 0 ;
   		while (flag.flag) {
   			i++;
   		}
   		System.out.printf("VolatileTask: Stopped %d - %s\n", i, new Date());
   	}
   }
   ```

7. 实现包含main()方法的Main类。首先，创建VolatileFlag、Flag、VolatileTask和Task类的四个对象：

   ```java
   public class Main {
   	public static void main(String[] args) {
   		VolatileFlag volatileFlag=new VolatileFlag();
   		Flag flag=new Flag();
   		VolatileTask vt=new VolatileTask(volatileFlag);
   		Task t=new Task(flag);
   ```

8. 然后，创建两个线程执行这些任务，启动线程，休眠主线程1秒钟：

   ```java
   		Thread thread=new Thread(vt);
   		thread.start();
   		thread=new Thread(t);
   		thread.start();
   		try {
   			TimeUnit.SECONDS.sleep(1);
   		} catch (InterruptedException e) {
   			e.printStackTrace();
   		}
   ```

9. 接下来改变volatileFlag变量值来停止volatileTask执行，并且休眠主线程1秒钟 ：

   ```java
   		System.out.printf("Main: Going to stop volatile task: %s\n",new Date());
   		volatileFlag.flag=false;
   		System.out.printf("Main: Volatile task stoped: %s\n", new Date());
   		try {
   			TimeUnit.SECONDS.sleep(1);
   		} catch (InterruptedException e) {
   			e.printStackTrace();
   		}
   ```

10. 最后，改变task对象值来停止任务执行，并且休眠主线出1秒钟：

    ```java
    		System.out.printf("Main: Going to stop task: %s\n", new Date());
    		flag.flag=false;
    		System.out.printf("Main: Volatile stop flag changed: %s\n", new Date());
    		try {
    			TimeUnit.SECONDS.sleep(1);
    		} catch (InterruptedException e) {
    			e.printStackTrace();
    		}
    	}
    }
    ```

### 工作原理

下图显示本范例的输出结果：

![pics/07_05.jpg](pics/07_05.jpg)

因为task线程还没有结束，所以此应用并没有完成执行。当改变volatileFlag值时，因为flag属性标记为volatile，所以新值被写入到主内存中，且VolatileTask立即访问这个值并结束执行。与之相反，当改变flag对象值时，因为flag属性未标记为volatile，所以新值存储到主线程的缓存中，并且任务对象无法看到新值，始终不会结束执行。volatile关键字非常重要，不仅因为它需要刷新写操作，而且确保读取不会被缓存，并且从主内存中获取最新的值。volatile非常重要，但也经常被忽视。

考虑到volatile关键字保证修改是在主内存中写入的，但其相反情况并不总是正确的。 例如，处理被多个线程共享且做出大量修改的非易失性整型值，可能会看到其他线程所做的修改，因为它们是在主内存中写入的。但是，不能保证这些更改是从缓存传递到主内存中的。

### 扩展学习 

只有当共享变量的值仅被一个线程修改时，volatile关键字才能正常工作。如果变量被多个线程修改，则volatile关键字无法在数据竞争条件下提供保护。 它也对操作如+或-、原子操作起作用，例如，作用在非易失性变量上的++操作符是线程不安全的。

自从Java 5，**Java内存模型**用volatile关键字建立了前置保证，包含两个特性：

- 当修改易失性变量时，变量值发送到主内存。也将发送之前由同一线程修改的所有变量值。
- 编译器不能重新排序那些为了优化目的而修改volatile变量的语句。它可以重新排序以前和之后的操作，但是不能修改volatile变量，这些修改之前发生的更改将对这些指令可见。 

### 更多关注

- 本章“使用原子变量”和“使用原子数组”小节

## 使用变量句柄

变量句柄是Java 9的一个新特性，获取对变量(属性、静态字段或数组元素)的类型化引用，以便以不同的模式进行访问。例如，通过允许对此变量的原子访问来保护在并发应用程序中对其访问。到目前为止，只能使用原子变量获得此行为，但现在能够使用变量句柄获得相同的功能，且无需使用任何同步机制。变量句柄还能够得到访问变量的附加模式。

本节将学习如获得和使用变量句柄，以及使用变量句柄的好处。

### 准备工作

本范例通过Eclipse开发工具实现。如果使用诸如NetBeans的开发工具，打开并创建一个新的Java项目。

### 实现过程

通过如下步骤实现范例：

1. 创建名为Account的类，包含两个名为amount和unsafeAmount的公有双精度属性，实现类构造函数，初始化属性值：

   ```java
   public class Account {
   	public double amount;
   	public double unsafeAmount;
   	
   	public Account() {
   		this.amount=0;
   		this.unsafeAmount=0;
   	}
   }
   ```

2. 创建名为Decrementer的类，指定其实现Runnable接口，包含在类构造函数中初始化的私有Account属性：

   ```java
   public class Decrementer implements Runnable{
   
   	private Account account;
   	
   	public Decrementer(Account account) {
   		this.account = account;
   	}
   ```

3. 实现run()方法，此方法将在amount和unsafeAmount属性中进行10000个递减操作。使用VarHandle来修改amount属性值，使用MethodHandles类的lookup()方法得到属性，然后使用getAndAdd()方法修改属性值。为了修改unsafeAmount属性，使用=操作符：

   ```java
   	@Override
   	public void run() {
   		VarHandle handler;
   		try {
   			handler = MethodHandles.lookup().in(Account.class).findVarHandle(Account.class, "amount",double.class);
   			for (int i = 0; i < 10000; i++) {
   				handler.getAndAdd(account, -100);
   				account.unsafeAmount -= 100;
   			}
   		} catch (NoSuchFieldException | IllegalAccessException e) {
   			e.printStackTrace();
   		}
   	}
   }
   ```

4. 实现名为Incrementer的类，此类与Decrementer类相似，但是递增账户值。此类的源代码不在此列出。

5. 最后，实现包含main()方法的Main类。首先，创建account对象：

   ```java
   public class Main {
   
   	public static void main(String[] args) {
   		Account account = new Account();
   ```

6. 然后，创建执行Incrementer和Decremente任务的线程。启动这两个线程，使用join()方法等待线程执行结束：

   ```java
   		Thread threadIncrementer = new Thread(new Incrementer(account));
   		Thread threadDecrementer = new Thread(new Decrementer(account));
   		threadIncrementer.start();
   		threadDecrementer.start();
   		
   		try {
   			threadIncrementer.join();
   			threadDecrementer.join();
   		} catch (InterruptedException e) {
   			e.printStackTrace();
   		}
   ```

7. 最后，输出amount和unsafeAmount属性值到控制台：

   ```java
   		System.out.printf("Safe amount: %f\n", account.amount);
   		System.out.printf("Unsafe amount: %f\n", account.unsafeAmount);
   	}
   }
   ```

### 工作原理

下图显示本范例的输出结果：

![pics/07_06.jpg](pics/07_06.jpg)

因为设置的递增和递减操作次数相同，所以两个属性的期望结果应是0。amount属性得到这个结果，因为当使用VarHandle访问它时，确保对其修改进行原子访问。另一方面，unsafeAmount没有得到预期值，因为访问值时不受保护，具备数据竞争条件。

为了使用变量句柄，首先要使用MethodHandles类的lookup()方法得到此变量，接下来是in()方法和findVarHandle()方法。lookup()方法返回Lookup对象，in()方法返回指定类的Lookup对象，在本范例中是Account类，然后findVarHandle()为要访问的属性生成VarHandle。

一旦具有VarHandle对象，就能够使用不同的方法来应用不同的访问模式。本范例中用到了getAndAdd()方法。此方法保证原子访问来增加属性值，将要访问的对象和增量的值传递给它们。

接下来提供关于不同访问模式和在每种情况下可以使用的方法的更多信息。

### 扩展学习

对于具有变量句柄的变量，有四种不同的访问类型：

- **读模式：**用于获取对变量的读模式访问，可以使用如下方法：
  - get()：如果变量被声明为非易失性，读取变量值
  - getVolatile()：如果变量被声明为易失性，读取变量值
  - getAcquire()：读取变量值，确保修改或访问该此变量的指令不会在用于优化目的的指令之前被重新排序 
  - getOpaque()：读取变量值，确保当前线程指令不会被重新排序，但无法保证其它线程
- **写模式：**用于获取对变量的写模式访问。可以使用set()、setVolatile()、setRelease()和setOpaque()方法，这些方法与读模式方法相似，不过具有写入访问。
- **原子访问模式：**用于获取具有操作的原子变量提供的相似功能 ，例如，比较和获取变量值。可以使用如下方法：
  - compareAndSet()：如果作为参数传递的期望值等于变量的当前值，将变量的值更改为volatile变量
  - weakCompareAndSet()和weakCompareAndSetVolatile()：如果作为参数传递的期望值等于变量的当前值，因为它被分别声明为非易失性变量或易失性变量，则可能以原子方式改变变量值    
- **数值更新访问模式：**用原子方式修改数值。

###更多关注

-  本章“使用原子变量”和“使用原子数组”小节